{
  "game:tabname-signalslink": "Signals Link",
  "signalslink:block-blocksensor-*": "Capteur de bloc",
  "signals:con-input": "Entrée",
  "signals:con-output": "Sortie",
  "signals:con-target": "Cible",
  "signals:con-source": "Source",
  "signalslink:block-entitysensor-*": "Capteur d'entités",
  "signals:con-x": "X",
  "signals:con-y": "Y",
  "signals:con-z": "Z",
  "signals:con-error-state": "État d'erreur",
  "signals:con-output1": "Sortie 1",
  "signals:con-output2": "Sortie 2",
  "signals:con-output1-config": "Configuration de la sortie 1",
  "signals:test": "Nous testons les traductions pendant la session d'IA.",
  "signals:con-output2-config": "Configuration de la sortie 2",
  "signalslink:entitysensor-charged": "Chargé. {0} unités ajoutées. La limite maximale de charge est de {1} unités.",
  "signalslink:entitysensor-already-fully-charged": "Cet appareil est déjà entièrement chargé.",
  "signalslink:blockinfo-charge": "Charge : {0}/{1} unités ({2}%)",
  "signalslink:blockinfo-charge-at-volume": "Avec la couverture actuelle ({0} blocs), il pourra fonctionner : ~{1} jours",
  "signalslink:blockinfo-charge-empty": "Charge : vide - nécessite un temporal gear",
  "signalslink:usageinfo-signalslink-title": "SignalsLink - extension du mod Signals",
  "signalslink:block-managedchute-*": "Conduit contrôlé",
  "signalslink:block-managedwallchute-wood-*": "Conduit contrôlé encastré dans le bois",
  "signalslink:block-managedwallchute-rock-*": "Conduit contrôlé encastré dans la roche",
  "signalslink:block-managedwallchute-cobble-*": "Conduit contrôlé encastré dans les dalles",
  "signalslink:managedchute-conditions": "Conditions",
  "signalslink:managedchute-info-unlimited": "Transporte en continu",
  "signalslink:managedchute-info-remaining": "Transporte {0}",
  "signalslink:block-handbooktitle-signalslink": "Fonctions de signal",
  "signalslink:block-handbooktext-blocksensor": "    Le capteur de blocs détecte la présence d’un bloc sur la position adjacente sélectionnée et, selon son type ou éventuellement le signal d’entrée, fournit en sortie une information sur son état ou le remplissage des emplacements.    <br>    <font size=\"20\" color=\"6082B6\">Blocs actuellement pris en charge :</font>    <br>    <strong>Enclume</strong> - si un lingot suffisamment chaud pour le forgeage se trouve sur l’enclume, le signal de sortie est 1. Sinon, il envoie le signal 0.    <br>    <strong>Portes, barrières, trappes</strong> - pour les portes et les barrières, il faut surveiller le bloc au niveau du sol du côté des charnières. Si le bloc est ouvert, le signal de sortie est 1 ; s’il est fermé, le signal de sortie est 0.    <br>    <strong>Coffre ou, plus généralement, conteneur, ou tout bloc possédant des emplacements d’inventaire</strong> (p. ex. foyer, tonneau, auge, etc.). Le signal de sortie dépend du signal d’entrée.    <br>    Le signal d’entrée détermine quel emplacement doit être scanné.    <br>    Le signal 1-14 correspond aux emplacements 0-13. La sortie est une information sur le remplissage de l’emplacement par rapport à la capacité maximale de pile de l’objet dans cet emplacement, convertie en un signal 0-15.    <br>    Le signal 15 indique que le capteur doit détecter le remplissage total de tous les emplacements, par ex. celui d’un coffre entier.    <br>    <strong>Un autre bloc, non listé ci-dessus</strong> - S’il n’y a rien dans l’espace surveillé (c’est de l’air), le signal de sortie est 0. S’il y a de l’eau, la sortie est 2—eau douce ou 3—eau salée. S’il y a n’importe quel autre bloc, le signal de sortie est 1.    <br>",
  "signalslink:block-handbooktext-entitysensor": "    Le capteur d’entités détecte la présence d’entités (joueurs, animaux, animaux sauvages ou monstres) dans la zone marquée et peut fournir en sortie des informations sur leur nombre, leur type ou leur état. Le capteur nécessite, pour fonctionner, d’être chargé avec une ou plusieurs roues temporelles (Temporal gears). La vitesse de consommation dépend ensuite de la taille de la zone surveillée.    <br>    Les <strong>entrées x, y, z</strong> déterminent la taille de la zone surveillée en blocs.    <br>    Sur la sortie <strong>Erreur</strong>, le signal est 1 si le capteur est déchargé, sinon 0.    <br>    Les entrées <strong>Réglage de la sortie 1</strong> et <strong>Réglage de la sortie 2</strong> déterminent quelles informations seront fournies sur les sorties 1 et 2. Vous pouvez ainsi obtenir une information différente sur chaque sortie, selon le réglage de ces entrées.    <br>    Les possibilités sont :    <br>    1 - La sortie renvoie le <strong>Nombre</strong>. Le nombre d’entités détectées.    <br>    2 - La sortie renvoie la <strong>Catégorie</strong>. Drapeaux binaires de la catégorie des entités 0–3 : joueur, créature, animal, animal sauvage.    <br>    3 - La sortie renvoie l’<strong>État de vie</strong>. Toutes les entités détectées sont : 1—mortes, 2—vivantes ou 15—mixtes.    <br>    4 - La sortie renvoie le <strong>Sexe</strong>. Toutes les entités détectées sont : 1—mâle, 2—femelle ou 15—mixtes.    <br>    5 - La sortie renvoie l’<strong>Âge</strong>. Toutes les entités détectées sont : 1—bébé, 2—adulte ou 15—mixtes.    <br>    6 - La sortie renvoie l’<strong>Espèce</strong>. Toutes les entités détectées sont : 1—joueur, 2—animal, 3—animal sauvage, 4—créature ou 15—mixtes.    <br>    7 - La sortie renvoie l’<strong>État reproductif</strong>. Toutes les entités détectées sont : 1—prêtes à s’accoupler, 2—gestantes, 3—allaitantes ou 15—mixtes.    <br>    8 - La sortie renvoie les <strong>Drapeaux d’état reproductif</strong>. Drapeaux binaires 0–2 : prêtes à s’accoupler, gestantes, allaitantes.    <br>    9 - La sortie renvoie la <strong>Génération minimale</strong>. La génération minimale détectée est : 0–15. Les entités présentes sans génération déterminée sont ignorées.    <br>    10 - La sortie renvoie la <strong>Génération maximale</strong>. La génération maximale détectée est : 0–15. Les entités présentes sans génération déterminée sont ignorées.    <br>    11 - La sortie renvoie le <strong>Poids minimal</strong>. Le poids minimal détecté est : 1—affamé, 2—faible, 3—correct, 4—bon. Les entités présentes sans poids déterminé (ce ne sont pas des animaux) sont ignorées.    <br>    12 - La sortie renvoie le <strong>Poids maximal</strong>. Le poids maximal détecté est : 1—affamé, 2—faible, 3—correct, 4—bon. Les entités présentes sans poids déterminé (ce ne sont pas des animaux) sont ignorées.    <br>",
  "signalslink:block-handbooktext-managedchute": "    La goulotte contrôlée permet le transport automatisé d’objets entre différents blocs.",
  "signalslink:block-handbooktext-managedwallchute": "    La goulotte contrôlée intégrée dans un mur permet le transport automatisé d’objets entre différents blocs. Elle permet de transporter des objets à travers les murs, ce qui peut être très utile pour des systèmes de transport cachés    ou pour transporter des objets depuis la cave ou vers la cave, sans perturber l’environnement frais de la cave, important pour la conservation à long terme des aliments.",
  "signalslink:usageinfo-signalslink-text": "    <font size=\"25\"><strong>SignalsLink</strong></font>    <br>    Étend le mod <a href=\"handbook://signals:craftinginfo-signals\">Signals</a> avec des composants supplémentaires.    <br>    <br>    Pour surveiller un bloc à proximité, vous pouvez utiliser le <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Capteur de blocs</a>.    <br>    Si vous devez surveiller votre troupeau de bétail, le <a href=\"handbook://block-signalslink:entitysensor-off-north-down\">Capteur d’entités</a> est parfait pour cela.    <br>    Si vous voulez automatiser certaines tâches, la <a href=\"handbook://block-signalslink:managedchute-north-down\">Goulotte contrôlée</a> vous sera très utile ; elle peut transporter des objets entre des blocs comme une goulotte, mais vous la pilotez avec des signaux et elle vous donne    un contrôle bien plus grand sur ce qui est transporté. Sa variante <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">Goulotte contrôlée intégrée dans un mur</a> permet ensuite de transporter des objets à travers les murs, ce qui peut être très utile pour des systèmes de transport cachés    ou pour transporter des objets depuis la cave ou vers la cave, sans perturber l’environnement frais de la cave, important pour la conservation à long terme des aliments.",
  "signalslink:usageinfo-paperconditions-text": "    Certains blocs du mod <a href=\"handbook://signalslink:usageinfo-signalslink\">SignalsLink</a> permettent d’utiliser des <strong>conditions sur papier</strong> :    <br>    • <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Capteur de blocs</a>    <br>    • <a href=\"handbook://block-signalslink:managedchute-north-down\">Goulotte contrôlée</a>    <br>    • <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">Goulotte contrôlée intégrée dans un mur</a>    <br>    <font size=\"20\" color=\"6082B6\">Conditions sur papier</font>    Les <strong>conditions sur papier</strong> sont des conditions écrites sur du <a href=\"handbook://item-paper-parchment\">parchemin</a>. Ces conditions peuvent être utilisées pour influencer le comportement d’un bloc, par exemple pour piloter les signaux de sortie ou pour filtrer les objets dans les goulottes.    <br>    Les conditions s’écrivent en blocs (paragraphes). Chaque bloc se compose d’une ou plusieurs lignes, chaque ligne contenant une condition. Toutes les conditions <strong>dans un même bloc</strong> sont évaluées en appliquant l’opérateur logique AND entre elles    et le résultat donne la valeur finale de l’ensemble du bloc.    <br>    Les blocs individuels sont séparés par une ligne vide. Sur les valeurs finales des différents blocs, on applique ensuite l’opérateur logique OR. L’évaluation des conditions au sein d’un bloc se fait de haut en bas, dans l’ordre où elles sont écrites sur le papier.    L’évaluation des blocs se fait aussi dans l’ordre où les blocs sont écrits sur le papier. Cela signifie que dès qu’un bloc est évalué comme vrai (true), ce résultat est renvoyé au bloc appelant et les blocs suivants ne sont plus évalués.    C’est très important et il faut en tenir compte.    <br>    <br>    Nous distinguons plusieurs types de conditions :    <br>    <strong>game:plank-oak</strong> - On vérifie si l’objet surveillé dans l’inventaire ou le bloc surveillé est du type indiqué, c.-à-d. si son code correspond exactement au code donné. Si oui, la condition renvoie true.<br>    <strong>game:plank-*</strong> - On vérifie si l’objet ou le bloc surveillé est du type indiqué, dans n’importe laquelle de ses variantes (marquées par l’astérisque). Si oui, la condition renvoie true.<br>    <strong>@.*-plank-.*</strong> - Le code de l’objet ou du bloc surveillé est évalué à l’aide de cette expression régulière. S’il y a correspondance, la condition renvoie true.<br>    <strong>attribut > 1</strong> - On évalue la valeur d’un attribut de l’objet dans l’inventaire ou du bloc surveillé. Divers opérateurs de comparaison peuvent être utilisés (supérieur/inférieur/égal). Après évaluation, on renvoie le résultat de la comparaison (true/false).<br>    <strong>attribut</strong> - Si seule le nom de l’attribut est indiqué dans la condition, on évalue s’il a ou non une valeur. Ainsi, zéro, NULL, chaîne vide ou false sont évalués comme false. Une valeur non nulle, une chaîne ou true sont évalués comme true.<br>    <br>    L’opérateur de négation <strong>!</strong> peut être appliqué à toutes les conditions. Par exemple, !game:plank-oak est évalué comme true si l’objet ou le bloc surveillé n’est pas exactement des planches de chêne.    <br>    À la fin de chaque bloc, on peut ajouter une instruction de réglage du signal de sortie, par exemple <strong>output 1</strong>, qui indique que si ce bloc est évalué comme vrai (true), un signal 1 sera envoyé en sortie.    Cela n’a de sens que pour le bloc <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Capteur de blocs</a>, qui permet de définir quel signal sera envoyé en sortie au cas où un bloc ou un objet correspond aux conditions indiquées dans le bloc. Pour les autres blocs qui permettent d’utiliser des conditions sur papier, cette instruction est ignorée.    <font size=\"20\" color=\"6082B6\">Configuration des conditions</font>    Écrivez les conditions sur du <a href=\"handbook://item-paper-parchment\">parchemin</a>. Ne signez pas le parchemin afin de pouvoir modifier le texte ultérieurement.<br>    Transférez les conditions dans un bloc qui les prend en charge en cliquant avec le bouton droit de la souris sur ce bloc avec ce parchemin. Les conditions seront ainsi enregistrées dans le bloc et vous les verrez dans la fenêtre d’information lorsque vous regarderez le bloc. <br>    Pour supprimer les conditions d’un bloc, prenez un parchemin vierge en main, accroupissez-vous (touche shift) et cliquez sur ce bloc avec ce parchemin vierge. Les conditions sont ainsi effacées du bloc.<br>    Si vous voulez copier les conditions d’un bloc sur un parchemin vierge, cliquez avec le bouton droit de la souris sur le bloc avec un parchemin vierge sans vous accroupir.<br>    Et enfin, une aide pour savoir quel code a un bloc ou un objet et quels attributs sont disponibles pour être utilisés dans les expressions conditionnelles :<br>    Prenez en main l’objet qui vous intéresse, maintenez la touche ctrl et cliquez avec le bouton droit de la souris sur un bloc qui prend en charge les conditions sur papier avec cet objet. Le code de l’objet et ses attributs, disponibles pour les conditions sur papier, seront enregistrés dans ce bloc. Vous pouvez maintenant les copier sur un parchemin vierge, comme décrit ci-dessus, puis les modifier librement en blocs de conditions et les utiliser pour configurer le bloc.",
  "signalslink:usageinfo-paperconditions-title": "Conditions sur papier"
}
