{
  "game:tabname-signalslink": "Signals Link",
  "signalslink:block-blocksensor-*": "Capteur de blocs",
  "signals:con-input": "Entrée",
  "signals:con-output": "Sortie",
  "signals:con-target": "Cible",
  "signals:con-source": "Source",
  "signalslink:block-entitysensor-*": "Capteur d'entités",
  "signals:con-x": "X",
  "signals:con-y": "Y",
  "signals:con-z": "Z",
  "signals:con-error-state": "État d'erreur",
  "signals:con-output1": "Sortie 1",
  "signals:con-output2": "Sortie 2",
  "signals:con-output1-config": "Configuration de la sortie 1",
  "signals:test": "Nous testons des traductions pendant le cours d'IA.",
  "signals:con-output2-config": "Configuration de la sortie 2",
  "signalslink:entitysensor-charged": "Chargé. {0} unités ajoutées. La limite maximale de charge est de {1} unités.",
  "signalslink:entitysensor-already-fully-charged": "Cet appareil est déjà entièrement chargé.",
  "signalslink:blockinfo-charge": "Charge : {0}/{1} unités ({2}%)",
  "signalslink:blockinfo-charge-at-volume": "Avec la couverture actuelle ({0} blocs), il fonctionnera : ~{1} jours",
  "signalslink:blockinfo-charge-empty": "Charge : Vide - nécessite un engrenage temporel",
  "signalslink:usageinfo-signalslink-title": "SignalsLink - extension du mod Signals",
  "signalslink:block-managedchute-*": "Goulotte contrôlée",
  "signalslink:block-managedwallchute-wood-*": "Goulotte contrôlée encastrée dans le bois",
  "signalslink:block-managedwallchute-rock-*": "Goulotte contrôlée encastrée dans la pierre",
  "signalslink:block-managedwallchute-cobble-*": "Goulotte contrôlée encastrée dans les dalles",
  "signalslink:managedchute-conditions": "Conditions",
  "signalslink:managedchute-info-unlimited": "Transporte en continu",
  "signalslink:managedchute-info-remaining": "Transporte {0}",
  "signalslink:block-handbooktitle-signalslink": "Fonctions de signal",
  "signalslink:block-handbooktext-blocksensor": "    Le capteur de blocs détecte la présence d’un bloc à une position adjacente choisie et, en fonction de son type ou éventuellement du signal d’entrée, fournit en sortie une information sur son état ou sur le remplissage de ses slots.    <br>    <font size=\"20\" color=\"6082B6\">Les blocs actuellement pris en charge sont :<\\/font>    <br>    <strong>Enclume<\\/strong> - s’il y a sur l’enclume un lingot suffisamment chauffé pour la forge, la sortie émet un signal 1. Sinon, elle envoie un signal 0.    <br>    <strong>Portes, portails, trappes<\\/strong> - Pour les portes et les portails, il est nécessaire de surveiller le bloc au niveau du sol du côté des gonds. Si le bloc est ouvert, la sortie émet un signal 1, s’il est fermé, la sortie émet un signal 0.    <br>    <strong>Coffre ou, de manière générale, conteneur, ou tout bloc disposant de slots d’inventaire<\\/strong> (par ex. foyer, tonneau, auge, etc.). En sortie, le signal dépend du signal d’entrée.    <br>    Le signal d’entrée détermine quel slot doit être scanné.    <br>    Un signal 1–14 correspond aux slots 0–13. La sortie fournit une information sur le remplissage du slot par rapport à la capacité maximale de pile de l’objet dans ce slot, convertie en un signal 0–15.    <br>    Le signal 15 indique que le capteur doit détecter le remplissage global de tous les slots, par ex. d’un coffre entier.    <br>    <strong>Tout autre bloc non mentionné ci-dessus<\\/strong> - S’il n’y a rien dans l’espace surveillé (c’est de l’air), la sortie émet un signal 0. S’il y a de l’eau, la sortie émet 2 pour l’eau douce ou 3 pour l’eau salée. S’il y a n’importe quel autre bloc, la sortie émet un signal 1.    <br>",
  "signalslink:block-handbooktext-entitysensor": "    Le capteur d’entités détecte la présence d’entités (joueurs, animaux, animaux sauvages ou monstres) dans une zone définie et peut fournir sur ses sorties des informations sur leur nombre, leur type ou leur état. Pour fonctionner, le capteur doit être chargé avec une ou plusieurs <em>Temporal Gears<\\/em>. La vitesse de consommation dépend ensuite de la taille de la zone surveillée.    <br>    Les entrées <strong>x, y, z<\\/strong> définissent la taille de la zone surveillée en blocs.    <br>    Sur la sortie <strong>Erreur<\\/strong>, le signal est 1 si le capteur est déchargé, sinon 0.    <br>    Les entrées <strong>Réglage de la sortie 1<\\/strong> et <strong>Réglage de la sortie 2<\\/strong> déterminent quelles informations seront fournies sur les sorties 1 et 2. Vous pouvez ainsi obtenir une information différente sur chaque sortie, en fonction du réglage de ces entrées.    <br>    Les options sont :    <br>    1 - La sortie renvoie le <strong>Nombre<\\/strong>. Le nombre d’entités détectées.    <br>    2 - La sortie renvoie la <strong>Catégorie<\\/strong>. Indicateurs binaires de la catégorie des entités 0–3 : joueur, créature, animal, animal sauvage.    <br>    3 - La sortie renvoie l’<strong>État de vie<\\/strong>. Toutes les entités détectées sont : 1–mortes, 2–vivantes ou 15–mélangées.    <br>    4 - La sortie renvoie le <strong>Sexe<\\/strong>. Toutes les entités détectées sont : 1–mâle, 2–femelle ou 15–mélangées.    <br>    5 - La sortie renvoie l’<strong>Âge<\\/strong>. Toutes les entités détectées sont : 1–jeune, 2–adulte ou 15–mélangées.    <br>    6 - La sortie renvoie l’<strong>Espèce<\\/strong>. Toutes les entités détectées sont : 1–joueur, 2–animal, 3–animal sauvage, 4–créature ou 15–mélangées.    <br>    7 - La sortie renvoie l’<strong>État de reproduction<\\/strong>. Toutes les entités détectées sont : 1–prêtes à s’accoupler, 2–gestantes, 3–allaitantes ou 15–mélangées.    <br>    8 - La sortie renvoie les <strong>Indicateurs d’état de reproduction<\\/strong>. Indicateurs binaires 0–2 : prêtes à s’accoupler, gestantes, allaitantes.    <br>    9 - La sortie renvoie la <strong>Génération minimale<\\/strong>. La génération minimale détectée est : 0–15. Les entités présentes sans génération définie sont ignorées.    <br>    10 - La sortie renvoie la <strong>Génération maximale<\\/strong>. La génération maximale détectée est : 0–15. Les entités présentes sans génération définie sont ignorées.    <br>    11 - La sortie renvoie le <strong>Poids minimal<\\/strong>. Le poids minimal détecté est : 1–affamé, 2–faible, 3–correct, 4–bon. Les entités présentes sans poids défini (qui ne sont pas des animaux) sont ignorées.    <br>    12 - La sortie renvoie le <strong>Poids maximal<\\/strong>. Le poids maximal détecté est : 1–affamé, 2–faible, 3–correct, 4–bon. Les entités présentes sans poids défini (qui ne sont pas des animaux) sont ignorées.    <br>",
  "signalslink:block-handbooktext-managedchute": "    Le conduit contrôlé permet le transport automatisé d’objets entre différents blocs.",
  "signalslink:block-handbooktext-managedwallchute": "    Le conduit contrôlé intégré dans un mur permet le transport automatisé d’objets entre différents blocs. Il permet de transporter des objets à travers les murs, ce qui peut être très utile pour des systèmes de transport cachés    ou pour transporter des objets depuis ou vers une cave, sans compromettre l’environnement frais de la cave, important pour la conservation à long terme des aliments.",
  "signalslink:usageinfo-signalslink-text": "    <font size=\"25\"><strong>SignalsLink<\\/strong><\\/font>    <br>    Étend le mod <a href=\"handbook://signals:craftinginfo-signals\">Signals<\\/a> avec des composants supplémentaires.    <br>    <br>    Pour surveiller un bloc dans les environs, vous pouvez utiliser le <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Capteur de blocs<\\/a>.    <br>    Si vous avez besoin de surveiller votre troupeau de bétail, le <a href=\"handbook://block-signalslink:entitysensor-off-north-down\">Capteur d’entités<\\/a> sera parfaitement adapté.    <br>    Si vous souhaitez automatiser certains travaux, le <a href=\"handbook://block-signalslink:managedchute-north-down\">Conduit contrôlé<\\/a> vous sera très utile ; il peut transporter des objets entre les blocs comme une goulotte, mais vous le contrôlez par signaux, ce qui vous donne    un bien meilleur contrôle sur ce qui est transporté. Sa variante, le <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">Conduit contrôlé intégré dans un mur<\\/a>, permet ensuite de transporter des objets à travers les murs, ce qui peut être très utile pour des systèmes de transport cachés    ou pour transporter des objets depuis ou vers une cave, sans compromettre l’environnement frais de la cave, important pour la conservation à long terme des aliments.",
  "signalslink:usageinfo-paperconditions-text": "    Certains blocs du mod <a href=\"handbook://signalslink:usageinfo-signalslink\">SignalsLink<\\/a> permettent d’utiliser des <strong>conditions sur parchemin<\\/strong> :    <br>    • <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Capteur de blocs<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedchute-north-down\">Conduit contrôlé<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">Conduit contrôlé intégré dans un mur<\\/a>    <br>    <font size=\"20\" color=\"6082B6\">Conditions sur parchemin<\\/font>    Les <strong>conditions sur parchemin<\\/strong> sont des conditions écrites sur un <a href=\"handbook://item-paper-parchment\">parchemin<\\/a>. Ces conditions peuvent être utilisées pour influencer le comportement du bloc, par exemple pour contrôler les signaux de sortie ou filtrer les objets dans les conduits.    <br>    Les conditions sont écrites en blocs (paragraphes). Chaque bloc se compose d’une ou plusieurs lignes, chacune contenant une condition. Toutes les conditions <strong>d’un même bloc<\\/strong> sont évaluées en appliquant entre elles l’opérateur logique AND,    et le résultat donne la valeur finale de tout le bloc.    <br>    Les blocs individuels sont séparés par une ligne vide. L’opérateur logique OR est ensuite appliqué aux valeurs finales de chaque bloc. L’évaluation des conditions individuelles dans un bloc se fait dans l’ordre de haut en bas, tel qu’indiqué sur le parchemin.    L’évaluation des blocs se fait également dans l’ordre dans lequel ils sont inscrits sur le parchemin. Cela signifie que dès qu’un bloc est évalué comme vrai (true), ce résultat est renvoyé au bloc appelant et l’on ne passe plus au bloc suivant.    Ceci est très important et il faut en tenir compte.    <br>    <br>    On distingue plusieurs types de conditions :    <br>    <strong>game:plank-oak<\\/strong> - On évalue si l’objet surveillé dans l’inventaire ou le bloc surveillé est du type indiqué, c.-à-d. si son code correspond exactement au code donné. Si oui, la condition renvoie true.<br>    <strong>game:plank-*<\\/strong> - On évalue si l’objet ou le bloc surveillé est du type indiqué, dans n’importe quelle de ses variantes (marquées par une astérisque). Si oui, la condition renvoie true.<br>    <strong>@.*-plank-.*<\\/strong> - Le code de l’objet ou du bloc surveillé est évalué par cette expression régulière. S’il y a correspondance, la condition renvoie true.<br>    <strong>attribut > 1<\\/strong> - On évalue la valeur de l’attribut de l’objet dans l’inventaire ou du bloc surveillé. Il est possible d’utiliser différents opérateurs de comparaison (supérieur/inférieur/égal). Après évaluation, le résultat de la comparaison est renvoyé (true/false).<br>    <strong>attribut<\\/strong> - Si la condition ne contient que le nom de l’attribut de l’objet, on évalue s’il a ou non une valeur. C.-à-d. que zéro, NULL, chaîne vide ou false sont évalués comme false. Une valeur non nulle, une chaîne non vide ou true sont évalués comme true.<br>    <br>    Toutes les conditions peuvent être préfixées par l’opérateur de négation <strong>!<\\/strong>. Par exemple, !game:plank-oak est évalué comme true si l’objet ou le bloc surveillé n’est pas exactement des planches de chêne.    <br>    À la fin de chaque bloc, il est possible d’ajouter une instruction pour définir le signal de sortie, par exemple <strong>output 1<\\/strong>, qui indique que si ce bloc est évalué comme vrai (true), un signal 1 sera envoyé en sortie.    Cela n’a de sens que pour le bloc <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Capteur de blocs<\\/a>, qui permet de définir quel signal sera envoyé en sortie si un bloc ou un objet correspond aux conditions indiquées dans le bloc. Pour les autres blocs qui permettent d’utiliser des conditions sur parchemin, cette instruction est ignorée.    <font size=\"20\" color=\"6082B6\">Configuration des conditions<\\/font>    Vous écrivez les conditions sur un <a href=\"handbook://item-paper-parchment\">parchemin<\\/a>. Ne signez pas le parchemin afin de pouvoir modifier le texte ultérieurement.<br>    Vous transférez les conditions vers un bloc qui les prend en charge en cliquant avec le bouton droit de la souris sur ce bloc en tenant ce parchemin. Les conditions sont alors enregistrées dans le bloc et vous les verrez dans la fenêtre d’information lorsque vous regarderez le bloc. <br>    Pour supprimer les conditions d’un bloc, prenez un parchemin vierge en main, accroupissez-vous (touche Maj) et cliquez avec ce parchemin vierge sur le bloc. Vous avez ainsi effacé les conditions du bloc.<br>    Si vous souhaitez copier les conditions du bloc vers un parchemin vierge, cliquez avec le bouton droit de la souris en tenant le parchemin vierge sur le bloc, sans vous accroupir.<br>    Et enfin, une aide pour déterminer le code d’un bloc ou d’un objet et les attributs dont vous disposez pour les utiliser dans les expressions conditionnelles :<br>    Prenez en main l’objet qui vous intéresse, maintenez la touche Ctrl enfoncée et cliquez avec le bouton droit de la souris avec cet objet sur un bloc qui prend en charge les conditions sur parchemin. Le code de l’objet et ses attributs disponibles pour les conditions sur parchemin seront enregistrés dans ce bloc. Vous pouvez maintenant les copier sur    un parchemin vierge, comme décrit ci-dessus, puis les modifier librement en blocs de conditions et les utiliser pour configurer le bloc.",
  "signalslink:usageinfo-paperconditions-title": "Conditions sur parchemin"
}
