{
  "game:tabname-signalslink": "Signals Link",
  "signalslink:block-blocksensor-*": "Czujnik bloków",
  "signals:con-input": "Wejście",
  "signals:con-output": "Wyjście",
  "signals:con-target": "Cel",
  "signals:con-source": "Źródło",
  "signalslink:block-entitysensor-*": "Czujnik istot",
  "signals:con-x": "X",
  "signals:con-y": "Y",
  "signals:con-z": "Z",
  "signals:con-error-state": "Stan błędu",
  "signals:con-output1": "Wyjście 1",
  "signals:con-output2": "Wyjście 2",
  "signals:con-output1-config": "Ustawienia wyjścia 1",
  "signals:test": "Testujemy tłumaczenia w AI godzince.",
  "signals:con-output2-config": "Ustawienia wyjścia 2",
  "signalslink:entitysensor-charged": "Naładowano. Dodano {0} jednostek. Maksymalny limit naładowania to {1} jednostek.",
  "signalslink:entitysensor-already-fully-charged": "To urządzenie jest już w pełni naładowane.",
  "signalslink:blockinfo-charge": "Naładowanie: {0}/{1} jednostek ({2}%)",
  "signalslink:blockinfo-charge-at-volume": "Przy aktualnym zasięgu ({0} bloków) będzie działać: ~{1} dni",
  "signalslink:blockinfo-charge-empty": "Naładowanie: Puste - potrzebuje temporal gear",
  "signalslink:usageinfo-signalslink-title": "SignalsLink - rozszerzenie modu Signals",
  "signalslink:block-managedchute-*": "Sterowana rura",
  "signalslink:block-managedwallchute-wood-*": "Sterowana rura osadzona w drewnie",
  "signalslink:block-managedwallchute-rock-*": "Sterowana rura osadzona w skale",
  "signalslink:block-managedwallchute-cobble-*": "Sterowana rura osadzona w płytkach",
  "signalslink:managedchute-conditions": "Warunki",
  "signalslink:managedchute-info-unlimited": "Transportuje stale",
  "signalslink:managedchute-info-remaining": "Transportuje {0}",
  "signalslink:block-handbooktitle-signalslink": "Funkcje sygnałowe",
  "signalslink:block-handbooktext-blocksensor": "    Czujnik bloków wykrywa obecność bloku w wybranej sąsiedniej pozycji i na podstawie jego typu, ewentualnie sygnału wejściowego, przekazuje na wyjściu informację o jego stanie lub zapełnieniu slotów.    <br>    <font size=\"20\" color=\"6082B6\">Aktualnie obsługiwane bloki to:<\\/font>    <br>    <strong>Kowadło<\\/strong> - jeśli na kowadle znajduje się wystarczająco rozgrzany do kucia wlew, na wyjściu jest sygnał 1. W przeciwnym razie wysyła sygnał 0.    <br>    <strong>Drzwi, bramy, klapy<\\/strong> - W przypadku drzwi i bram należy obserwować blok przy ziemi po stronie zawiasów. Jeśli blok jest otwarty, na wyjściu jest sygnał 1, jeśli jest zamknięty, na wyjściu jest sygnał 0.    <br>    <strong>Skrzynia lub ogólnie kontener albo dowolne bloki, które mają jakieś sloty ekwipunku<\\/strong> (np. palenisko, beczka, koryto itp.). Na wyjściu jest sygnał zgodny z sygnałem wejściowym.    <br>    Sygnał wejściowy określa, który slot ma być skanowany.    <br>    Sygnał 1–14 określa sloty 0–13. Wyjściem jest informacja o zapełnieniu slotu względem maksymalnej pojemności stosu przedmiotu w danym slocie, przeliczonej na sygnał 0–15.    <br>    Sygnał 15 określa, że czujnik ma wykrywać całkowite zapełnienie wszystkich slotów, np. całej skrzyni.    <br>    <strong>Jakiś inny blok, niewymieniony powyżej<\\/strong> - Jeśli w obserwowanej przestrzeni nic nie ma (jest tam powietrze), na wyjściu jest sygnał 0. Jeśli jest tam woda, na wyjściu jest 2 – słodka lub 3 – słona woda. Jeśli znajduje się tam jakikolwiek inny blok, na wyjściu jest sygnał 1.    <br>",
  "signalslink:block-handbooktext-entitysensor": "    Czujnik istot wykrywa obecność bytów (graczy, zwierząt, dzikich zwierząt lub potworów) w wyznaczonym obszarze i potrafi na wyjściach udostępniać informacje o ich liczbie, typie lub stanie. Do pracy wymaga naładowania    jednym lub kilkoma kołami czasowymi (Temporal gears). Szybkość zużycia zależy od wielkości obserwowanego obszaru.    <br>    <strong>Wejścia x, y, z<\\/strong> określają wielkość obserwowanego obszaru w blokach.    <br>    Na wyjściu <strong>Błąd<\\/strong> jest sygnał 1, jeśli czujnik jest rozładowany, w przeciwnym razie 0.    <br>    Wejścia <strong>Ustawienie wyjścia 1<\\/strong> i <strong>Ustawienie wyjścia 2<\\/strong> określają, jakie informacje będą udostępniane na wyjściach 1 i 2. Na każdym wyjściu możesz więc uzyskać inną informację, na podstawie ustawień tych wejść.    <br>    Możliwe są:    <br>    1 - Wyjście zwraca <strong>Liczbę<\\/strong>. Liczbę wykrytych bytów.    <br>    2 - Wyjście zwraca <strong>Kategorię<\\/strong>. Bitowe znaczniki kategorii bytów 0–3: gracz, stworzenie, zwierzę, dzikie zwierzę.    <br>    3 - Wyjście zwraca <strong>Stan życia<\\/strong>. Wszystkie wykryte byty są: 1 – martwe, 2 – żywe lub 15 – mieszane.    <br>    4 - Wyjście zwraca <strong>Płeć<\\/strong>. Wszystkie wykryte byty są: 1 – samiec, 2 – samica lub 15 – mieszane.    <br>    5 - Wyjście zwraca <strong>Wiek<\\/strong>. Wszystkie wykryte byty są: 1 – młode, 2 – dorosłe lub 15 – mieszane.    <br>    6 - Wyjście zwraca <strong>Rodzaj<\\/strong>. Wszystkie wykryte byty są: 1 – gracz, 2 – zwierzę, 3 – dzikie zwierzę, 4 – stworzenie lub 15 – mieszane.    <br>    7 - Wyjście zwraca <strong>Stan rozrodczy<\\/strong>. Wszystkie wykryte byty są: 1 – gotowe do rozrodu, 2 – ciężarne, 3 – karmiące lub 15 – mieszane.    <br>    8 - Wyjście zwraca <strong>Flagi stanu rozrodczego<\\/strong>. Bitowe znaczniki 0–2: gotowe do rozrodu, ciężarne, karmiące.    <br>    9 - Wyjście zwraca <strong>Minimalne pokolenie<\\/strong>. Minimalnie wykryte pokolenie to: 0–15. Obecne byty bez określonego pokolenia są ignorowane.    <br>    10 - Wyjście zwraca <strong>Maksymalne pokolenie<\\/strong>. Maksymalnie wykryte pokolenie to: 0–15. Obecne byty bez określonego pokolenia są ignorowane.    <br>    11 - Wyjście zwraca <strong>Minimalną masę<\\/strong>. Minimalnie wykryta masa to: 1 – wygłodzone, 2 – niska, 3 – przyzwoita, 4 – dobra. Obecne byty bez określonej wagi (nie są to zwierzęta) są ignorowane.    <br>    12 - Wyjście zwraca <strong>Maksymalną masę<\\/strong>. Maksymalnie wykryta masa to: 1 – wygłodzone, 2 – niska, 3 – przyzwoita, 4 – dobra. Obecne byty bez określonej wagi (nie są to zwierzęta) są ignorowane.    <br>",
  "signalslink:block-handbooktext-managedchute": "    Sterowana rura umożliwia zautomatyzowany transport przedmiotów między różnymi blokami.",
  "signalslink:block-handbooktext-managedwallchute": "    Sterowana rura osadzona w ścianie umożliwia zautomatyzowany transport przedmiotów między różnymi blokami. Umożliwia przenoszenie przedmiotów przez ściany, co może być bardzo przydatne dla ukrytych systemów transportowych    albo do transportu przedmiotów z piwnicy lub do piwnicy, bez naruszania chłodnego piwnicznego środowiska, ważnego dla długotrwałego przechowywania żywności.",
  "signalslink:usageinfo-signalslink-text": "    <font size=\"25\"><strong>SignalsLink<\\/strong><\\/font>    <br>    Rozszerza mod <a href=\"handbook://signals:craftinginfo-signals\">Signals<\\/a> o kolejne komponenty.    <br>    <br>    Do obserwacji jakiegoś bloku w okolicy możesz użyć <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Czujnika bloków<\\/a>.    <br>    Jeśli potrzebujesz obserwować swoje stado bydła, doskonale nada się do tego <a href=\"handbook://block-signalslink:entitysensor-off-north-down\">Czujnik istot<\\/a>.    <br>    Jeśli chcesz zautomatyzować niektóre prace, świetnie posłuży ci <a href=\"handbook://block-signalslink:managedchute-north-down\">Sterowana rura<\\/a>, która potrafi przenosić przedmioty między blokami podobnie jak zsyp, ale sterujesz nią sygnałami i daje ci    znacznie większą kontrolę nad tym, co jest transportowane. Jej wariant <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">Sterowana rura wbudowana w ścianę<\\/a> umożliwia następnie przenoszenie przedmiotów przez ściany, co może być bardzo przydatne dla ukrytych systemów transportowych    albo do transportu przedmiotów z piwnicy lub do piwnicy, bez naruszania chłodnego piwnicznego środowiska, ważnego dla długotrwałego przechowywania żywności.",
  "signalslink:usageinfo-paperconditions-text": "    Niektóre bloki z modu <a href=\"handbook://signalslink:usageinfo-signalslink\">SignalsLink<\\/a> umożliwiają używanie <strong>warunków na pergaminie<\\/strong>:    <br>    • <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Czujnik bloków<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedchute-north-down\">Sterowana rura<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">Sterowana rura wbudowana w ścianę<\\/a>    <br>    <font size=\"20\" color=\"6082B6\">Warunki na pergaminie<\\/font>    <strong>warunki na pergaminie<\\/strong> to warunki zapisane na <a href=\"handbook://item-paper-parchment\">pergaminie<\\/a>. Warunki te mogą być użyte do wpływania na zachowanie bloku, na przykład do sterowania sygnałami wyjściowymi lub do filtrowania przedmiotów w rurach.    <br>    Warunki zapisuje się w blokach (akapitach). Każdy blok składa się z jednego lub więcej wierszy, przy czym w każdym wierszu podany jest jeden warunek. Wszystkie warunki <strong>w jednym bloku<\\/strong> są oceniane tak, że pomiędzy nimi stosowany jest operator logiczny AND    a wynik daje ostateczną wartość całego bloku.    <br>    Poszczególne bloki są od siebie oddzielone pustym wierszem. Na wynikowe wartości poszczególnych bloków następnie stosowany jest operator logiczny OR. Ocena poszczególnych warunków w bloku przebiega w kolejności z góry na dół, w jakiej są one podane na pergaminie.    Ocena bloków przebiega również w kolejności, w jakiej są podane na pergaminie. Oznacza to, że gdy jakiś blok zostanie oceniony jako prawda (true), ten wynik jest zwracany do bloku wywołującego i do kolejnego bloku już się nie przechodzi.    Jest to bardzo ważne i trzeba się z tym liczyć.    <br>    <br>    Rozróżniamy kilka typów warunków:    <br>    <strong>game:plank-oak<\\/strong> - Sprawdza się, czy obserwowany przedmiot w ekwipunku lub obserwowany blok jest zadanego typu, tzn. jego kod dokładnie odpowiada podanemu kodowi. Jeśli tak, warunek zwróci true.<br>    <strong>game:plank-*<\\/strong> - Sprawdza się, czy obserwowany przedmiot lub blok jest zadanego typu w dowolnej jego odmianie (oznaczonej gwiazdką). Jeśli tak, warunek zwróci true.<br>    <strong>@.*-plank-.*<\\/strong> - Kod obserwowanego przedmiotu lub bloku jest oceniany tym wyrażeniem regularnym. Jeśli jest zgodność, warunek zwróci true.<br>    <strong>attribut > 1<\\/strong> - Sprawdza się wartość atrybutu przedmiotu w ekwipunku lub obserwowanego bloku. Można tu używać różnych operatorów porównania (większy/mniejszy/równy). Po ocenie zwracany jest wynik porównania (true/false).<br>    <strong>attribut<\\/strong> - Jeśli w warunku podana jest tylko nazwa atrybutu przedmiotu, sprawdza się, czy ma on wartość, czy nie. Tzn. zero, NULL, pusty łańcuch lub false są oceniane jako false. Niezerowa wartość, łańcuch lub true są oceniane jako true.<br>    <br>    Do wszystkich warunków można zastosować operator negacji <strong>!<\\/strong>. Na przykład !game:plank-oak jest oceniane jako true, jeśli obserwowany przedmiot lub blok nie jest dokładnie dębową deską.    <br>    Na końcu każdego bloku można dodać instrukcję ustawienia sygnału wyjściowego, na przykład <strong>output 1<\\/strong>, która określa, że jeśli ten blok zostanie oceniony jako prawda (true), na wyjście zostanie wysłany sygnał 1.    Ma to znaczenie tylko w przypadku bloku <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Czujnik bloków<\\/a>, który umożliwia ustawienie, jaki sygnał zostanie wysłany na wyjście w przypadku, gdy jakiś blok lub przedmiot odpowiada warunkom podanym w bloku. W pozostałych blokach, które umożliwiają używanie warunków na pergaminie, ta instrukcja jest ignorowana.    <font size=\"20\" color=\"6082B6\">Ustawianie warunków<\\/font>    Warunki zapisujesz na <a href=\"handbook://item-paper-parchment\">pergaminie<\\/a>. Pergaminu nie podpisuj, abyś mógł ponownie edytować tekst.<br>    Warunki przeniesiesz do bloku, który to obsługuje, klikając tym pergaminem prawym przyciskiem myszy na dany blok. Warunki zostaną zapisane w bloku i zobaczysz je w oknie informacyjnym, gdy spojrzysz na blok. <br>    Aby usunąć warunki z bloku, weź do ręki pusty pergamin, przykucnij (klawisz shift) i kliknij tym pustym pergaminem na dany blok. W ten sposób warunki w bloku zostaną usunięte.<br>    Jeśli chcesz skopiować z bloku warunki na pusty pergamin, kliknij pustym pergaminem prawym przyciskiem myszy na dany blok bez kucania.<br>    I na koniec pomoc do ustalenia, jaki kod ma dany blok lub przedmiot i jakie masz do dyspozycji atrybuty do wykorzystania w wyrażeniach warunkowych:<br>    Weź do ręki przedmiot, który cię interesuje, przytrzymaj klawisz ctrl i kliknij prawym przyciskiem myszy tym blokiem na blok, który obsługuje warunki na pergaminie. Kod przedmiotu i jego atrybuty dostępne dla warunków na pergaminie zostaną zapisane w tym bloku. Możesz je teraz skopiować na     pusty pergamin, jak opisano powyżej, i tam dowolnie przerobić na bloki warunków oraz użyć do ustawienia bloku.",
  "signalslink:usageinfo-paperconditions-title": "Warunki na pergaminie"
}
