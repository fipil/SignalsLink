{
  "game:tabname-signalslink": "Signals Link",
  "signalslink:block-blocksensor-*": "Block Sensor",
  "signals:con-input": "Input",
  "signals:con-output": "Output",
  "signals:con-target": "Target",
  "signals:con-source": "Source",
  "signalslink:block-entitysensor-*": "Entity Sensor",
  "signals:con-x": "X",
  "signals:con-y": "Y",
  "signals:con-z": "Z",
  "signals:con-error-state": "Error state",
  "signals:con-output1": "Output 1",
  "signals:con-output2": "Output 2",
  "signals:con-output1-config": "Output 1 settings",
  "signals:test": "We are testing translations in the AI watch.",
  "signals:con-output2-config": "Output 2 settings",
  "signalslink:entitysensor-charged": "Charged. Added {0} units. The maximum charge limit is {1} units.",
  "signalslink:entitysensor-already-fully-charged": "This device is already fully charged.",
  "signalslink:blockinfo-charge": "Charge: {0}/{1} units ({2}%)",
  "signalslink:blockinfo-charge-at-volume": "At the current coverage ({0} blocks) it will keep working for: ~{1} days",
  "signalslink:blockinfo-charge-empty": "Charge: Empty - requires a temporal gear",
  "signalslink:usageinfo-signalslink-title": "SignalsLink - Signals mod extension",
  "signalslink:block-managedchute-*": "Managed chute",
  "signalslink:block-managedwallchute-wood-*": "Managed chute embedded in wood",
  "signalslink:block-managedwallchute-rock-*": "Managed chute embedded in rock",
  "signalslink:block-managedwallchute-cobble-*": "Managed chute embedded in cobblestone",
  "signalslink:managedchute-conditions": "Conditions",
  "signalslink:managedchute-info-unlimited": "Transports continuously",
  "signalslink:managedchute-info-remaining": "Transports {0}",
  "signalslink:block-handbooktitle-signalslink": "Signal functions",
  "signalslink:block-handbooktext-blocksensor": "    The block sensor detects the presence of a block at a selected adjacent position and, based on its type and possibly the input signal, provides information at the output about its state or the filling of its slots.    <br>    <font size=\"20\" color=\"6082B6\">The currently supported blocks are:<\\/font>    <br>    <strong>Anvil<\\/strong> - if there is a sufficiently hot ingot for forging on the anvil, the Output is signal 1. Otherwise it sends signal 0.    <br>    <strong>Doors, gates, trapdoors<\\/strong> - For doors and gates you need to monitor the block at ground level on the hinge side. If the block is open, the Output is signal 1, if it is closed, the Output is signal 0.    <br>    <strong>Chest or, in general, container or any blocks that have some inventory slots<\\/strong> (e.g. firepit, barrel, trough, etc.). The Output is a signal according to the input signal.    <br>    The input signal determines which slot is to be scanned.    <br>    Signals 1–14 specify slots 0–13. The output is information about the filling of the slot with respect to the maximum stack size of the item in that slot, converted to a 0–15 signal.    <br>    Signal 15 specifies that the sensor should detect the total filling of all slots, e.g. of the whole chest.    <br>    <strong>Some other block not listed above<\\/strong> - If there is nothing in the monitored space (there is air), the Output is signal 0. If there is water, the output is 2–fresh or 3–salt water. If there is any other block, the Output is signal 1.    <br>",
  "signalslink:block-handbooktext-entitysensor": "    The entity sensor detects the presence of entities (players, animals, wild animals or monsters) in a designated area and can provide information at its outputs about their number, type or state. The sensor requires one or more Temporal Gears for its operation. The rate of consumption then depends on the size of the monitored area.    <br>    <strong>Inputs x, y, z<\\/strong> determine the size of the monitored area in blocks.    <br>    At the <strong>Error<\\/strong> output there is signal 1 if the sensor is discharged, otherwise 0.    <br>    The <strong>Output 1 setting<\\/strong> and <strong>Output 2 setting<\\/strong> inputs determine what information will be provided on outputs 1 and 2. On each output you can thus obtain different information, based on the settings of these inputs.    <br>    The options are:    <br>    1 - The output returns <strong>Count<\\/strong>. The number of detected entities.    <br>    2 - The output returns <strong>Category<\\/strong>. Bit flags of the entity category 0–3: player, creature, animal, wild animal.    <br>    3 - The output returns <strong>Life state<\\/strong>. All detected entities are: 1–dead, 2–alive or 15–mixed.    <br>    4 - The output returns <strong>Sex<\\/strong>. All detected entities are: 1–male, 2–female or 15–mixed.    <br>    5 - The output returns <strong>Age<\\/strong>. All detected entities are: 1–juvenile, 2–adult or 15–mixed.    <br>    6 - The output returns <strong>Type<\\/strong>. All detected entities are: 1–player, 2–animal, 3–wild animal, 4–creature or 15–mixed.    <br>    7 - The output returns <strong>Reproductive state<\\/strong>. All detected entities are: 1–ready to mate, 2–pregnant, 3–lactating or 15–mixed.    <br>    8 - The output returns <strong>Reproductive state flags<\\/strong>. Bit flags 0–2: ready to mate, pregnant, lactating.    <br>    9 - The output returns <strong>Minimum generation<\\/strong>. The minimum detected generation is 0–15. Present entities without a defined generation are ignored.    <br>    10 - The output returns <strong>Maximum generation<\\/strong>. The maximum detected generation is 0–15. Present entities without a defined generation are ignored.    <br>    11 - The output returns <strong>Minimum weight<\\/strong>. The minimum detected weight is 1–starving, 2–low, 3–decent, 4–good. Present entities without a defined weight (not animals) are ignored.    <br>    12 - The output returns <strong>Maximum weight<\\/strong>. The maximum detected weight is 1–starving, 2–low, 3–decent, 4–good. Present entities without a defined weight (not animals) are ignored.    <br>",
  "signalslink:block-handbooktext-managedchute": "    The managed chute allows automated transport of items between different blocks.",
  "signalslink:block-handbooktext-managedwallchute": "    The managed chute embedded in a wall allows automated transport of items between different blocks. It allows you to transport items through walls, which can be very useful for hidden transport systems or for transporting items from or to a cellar without breaking the cool cellar environment, which is important for long-term food preservation.",
  "signalslink:usageinfo-signalslink-text": "    <font size=\"25\"><strong>SignalsLink<\\/strong><\\/font>    <br>    Extends the <a href=\"handbook://signals:craftinginfo-signals\">Signals<\\/a> mod with additional components.    <br>    <br>    To monitor a block in the vicinity you can use the <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Block Sensor<\\/a>.    <br>    If you need to monitor your herd of cattle, the <a href=\"handbook://block-signalslink:entitysensor-off-north-down\">Entity Sensor<\\/a> is perfect for that.    <br>    If you want to automate some tasks, the <a href=\"handbook://block-signalslink:managedchute-north-down\">Managed Chute<\\/a> will serve you very well, as it can transport items between blocks similarly to a chute, but you control it with signals and it gives you much greater control over what is transported. Its variant, the <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">Managed Chute built into the wall<\\/a>, then allows you to transport items through walls, which can be very useful for hidden transport systems or for transporting items from or to a cellar without breaking the cool cellar environment, which is important for long-term food preservation.",
  "signalslink:usageinfo-paperconditions-text": "    Some blocks from the <a href=\"handbook://signalslink:usageinfo-signalslink\">SignalsLink<\\/a> mod allow the use of <strong>conditions on paper<\\/strong>:    <br>    • <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Block Sensor<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedchute-north-down\">Managed Chute<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">Managed Chute built into the wall<\\/a>    <br>    <font size=\"20\" color=\"6082B6\">Conditions on paper<\\/font>    <strong>conditions on paper<\\/strong> are conditions written on <a href=\"handbook://item-paper-parchment\">parchment<\\/a>. These conditions can be used to influence the behavior of a block, for example to control output signals or to filter items in chutes.    <br>    Conditions are written into blocks (paragraphs). Each block consists of one or more lines, with one condition specified on each line. All conditions <strong>in one block<\\/strong> are evaluated so that the logical AND operator is applied between them and the result gives the final value of the whole block.    <br>    Individual blocks are separated by an empty line. The logical OR operator is then applied to the resulting values of the individual blocks. Evaluation of the individual conditions in a block takes place in the order from top to bottom, as the conditions are written on the paper. Evaluation of the blocks also takes place in the order in which the blocks are written on the paper. This means that as soon as some block evaluates to true, this result is returned to the calling block and the next block is no longer processed. This is very important and you need to take it into account.    <br>    <br>    We distinguish several types of conditions:    <br>    <strong>game:plank-oak<\\/strong> - It is evaluated whether the monitored item in the inventory or the monitored block is of the given type, i.e. its code exactly matches the given code. If so, the condition returns true.<br>    <strong>game:plank-*<\\/strong> - It is evaluated whether the monitored item or block is of the given type, in any of its variants (marked with an asterisk). If so, the condition returns true.<br>    <strong>@.*-plank-.*<\\/strong> - The code of the monitored item or block is evaluated using this regular expression. If there is a match, the condition returns true.<br>    <strong>attribute > 1<\\/strong> - The value of the attribute of the item in the inventory or the monitored block is evaluated. Various comparison operators can be used here (greater/less/equal). After evaluation, the result of the comparison (true/false) is returned.<br>    <strong>attribute<\\/strong> - If only the name of the item attribute is given in the condition, it is evaluated whether it has a value or not. That is, zero, NULL, empty string or false is evaluated as false. A non-zero value, string or true is evaluated as true.<br>    <br>    The negation operator <strong>!<\\/strong> can be applied to all conditions. For example, !game:plank-oak is evaluated as true if the monitored item or block is not exactly oak planks.    <br>    At the end of each block you can add an instruction to set the output signal, for example <strong>output 1<\\/strong>, which specifies that if this block evaluates to true, signal 1 will be sent to the output. This only has meaning for the <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Block Sensor<\\/a>, which allows you to set what signal will be sent to the output if some block or item matches the conditions specified in the block. For other blocks that allow the use of conditions on paper, this instruction is ignored.    <font size=\"20\" color=\"6082B6\">Setting up conditions<\\/font>    You write the conditions on <a href=\"handbook://item-paper-parchment\">parchment<\\/a>. Do not sign the parchment so that you can edit the text again.<br>    You transfer the conditions to a block that supports it by right-clicking that block with this parchment. The conditions are thus saved into the block and you will see them in the information window when you look at the block. <br>    To remove the conditions from a block, take an empty parchment in your hand, crouch (shift key) and right-click that block with the empty parchment. This deletes the conditions from the block.<br>    If you want to copy the conditions from a block to an empty parchment, right-click that block with an empty parchment without crouching.<br>    And finally, a helper for finding out what code some block or item has and what attributes you have available for use in conditional expressions:<br>    Take into your hand the item you are interested in, hold down the Ctrl key and right-click with this item on a block that supports conditions on paper. The item code and its attributes available for conditions on paper are stored in that block. You can now copy them onto an empty parchment, as described above, and freely edit them into blocks of conditions and use them to set up the block.",
  "signalslink:usageinfo-paperconditions-title": "Conditions on paper"
}
