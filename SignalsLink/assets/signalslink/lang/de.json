{
  "game:tabname-signalslink": "Signals Link",
  "signalslink:block-blocksensor-*": "Blocksensor",
  "signals:con-input": "Eingang",
  "signals:con-output": "Ausgang",
  "signals:con-target": "Ziel",
  "signals:con-source": "Quelle",
  "signalslink:block-entitysensor-*": "Wesensensor",
  "signals:con-x": "X",
  "signals:con-y": "Y",
  "signals:con-z": "Z",
  "signals:con-error-state": "Fehlerzustand",
  "signals:con-output1": "Ausgang 1",
  "signals:con-output2": "Ausgang 2",
  "signals:con-output1-config": "Ausgang 1 einstellen",
  "signals:test": "Wir testen Übersetzungen in der KI-Stunde.",
  "signals:con-output2-config": "Ausgang 2 einstellen",
  "signalslink:entitysensor-charged": "Aufgeladen. {0} Einheiten hinzugefügt. Das maximale Ladelimit beträgt {1} Einheiten.",
  "signalslink:entitysensor-already-fully-charged": "Dieses Gerät ist bereits vollständig aufgeladen.",
  "signalslink:blockinfo-charge": "Ladung: {0}/{1} Einheiten ({2}%)",
  "signalslink:blockinfo-charge-at-volume": "Bei aktueller Abdeckung ({0} Blöcke) kann es arbeiten für: ~{1} Tage",
  "signalslink:blockinfo-charge-empty": "Ladung: Leer - benötigt Temporal Gear",
  "signalslink:usageinfo-signalslink-title": "SignalsLink - Erweiterung des Mods Signals",
  "signalslink:block-managedchute-*": "Gesteuertes Rohr",
  "signalslink:block-managedwallchute-wood-*": "In Holz eingelassenes gesteuertes Rohr",
  "signalslink:block-managedwallchute-rock-*": "In Fels eingelassenes gesteuertes Rohr",
  "signalslink:block-managedwallchute-cobble-*": "In Fliesen eingelassenes gesteuertes Rohr",
  "signalslink:managedchute-conditions": "Bedingungen",
  "signalslink:managedchute-info-unlimited": "Transportiert dauerhaft",
  "signalslink:managedchute-info-remaining": "Transportiert {0}",
  "signalslink:block-handbooktitle-signalslink": "Signalfunktionen",
  "signalslink:block-handbooktext-blocksensor": "Der Blocksensor erkennt die Anwesenheit eines Blocks an einer ausgewählten benachbarten Position und liefert abhängig von dessen Typ bzw. vom Eingangssignal am Ausgang Informationen über seinen Zustand oder die Belegung von Slots.<br><font size=\"20\" color=\"6082B6\">Derzeit unterstützte Blöcke sind:</font><br><strong>Amboss</strong> – wenn sich auf dem Amboss ein ausreichend glühender Ingot zum Schmieden befindet, liegt am Ausgang Signal 1 an. Andernfalls sendet er Signal 0.<br><strong>Türen, Tore, Falltüren</strong> – bei Türen und Toren muss der Block am Boden auf der Scharnierseite überwacht werden. Wenn der Block geöffnet ist, liegt am Ausgang Signal 1 an, wenn er geschlossen ist, liegt am Ausgang Signal 0 an.<br><strong>Truhe oder allgemein Container bzw. beliebige Blöcke, die Inventar-Slots haben</strong> (z.B. Feuerstelle, Fass, Trog etc.). Am Ausgang liegt ein Signal entsprechend dem Eingangssignal an.<br>Das Eingangssignal bestimmt, welcher Slot gescannt werden soll.<br>Signal 1–14 bestimmt die Slots 0–13. Der Ausgang ist eine Information über die Füllung des Slots im Verhältnis zur maximalen Stack-Kapazität des Gegenstands in diesem Slot, umgerechnet in ein Signal 0–15.<br>Signal 15 bestimmt, dass der Sensor die Gesamtfüllung aller Slots erkennen soll, z.B. einer ganzen Truhe.<br><strong>Ein anderer Block, der oben nicht aufgeführt ist</strong> – Wenn sich im überwachten Raum nichts befindet (es ist dort Luft), liegt am Ausgang Signal 0 an. Wenn dort Wasser ist, liegt am Ausgang 2–Süßwasser oder 3–Salzwasser an. Wenn dort irgendein anderer Block ist, liegt am Ausgang Signal 1 an.<br>",
  "signalslink:block-handbooktext-entitysensor": "Der Entitätensensor erkennt die Anwesenheit von Entitäten (Spielern, Tieren, Wildtieren oder Monstern) im markierten Bereich und kann an den Ausgängen Informationen über deren Anzahl, Typ oder Zustand liefern. Der Sensor benötigt für den Betrieb eine Aufladung mit einem oder mehreren Zeit-Zahnrädern (Temporal gears). Die Verbrauchsgeschwindigkeit hängt dann von der Größe des überwachten Bereichs ab.<br><strong>Eingänge x, y, z</strong> bestimmen die Größe des überwachten Bereichs in Blöcken.<br>Am Ausgang <strong>Fehler</strong> liegt Signal 1 an, wenn der Sensor entladen ist, sonst 0.<br>Die Eingänge <strong>Ausgabe 1 einstellen</strong> und <strong>Ausgabe 2 einstellen</strong> bestimmen, welche Informationen an den Ausgängen 1 und 2 bereitgestellt werden. An jedem Ausgang kannst du so – abhängig von der Einstellung dieser Eingänge – eine andere Information erhalten.<br>Möglichkeiten sind:<br>1 – Der Ausgang liefert <strong>Anzahl</strong>. Anzahl der erkannten Entitäten.<br>2 – Der Ausgang liefert <strong>Kategorie</strong>. Bit-Flags der Entitätskategorie 0–3: Spieler, Kreatur, Tier, Wildtier.<br>3 – Der Ausgang liefert <strong>Lebensstatus</strong>. Alle erkannten Entitäten sind: 1–tot, 2–lebendig oder 15–gemischt.<br>4 – Der Ausgang liefert <strong>Geschlecht</strong>. Alle erkannten Entitäten sind: 1–männlich, 2–weiblich oder 15–gemischt.<br>5 – Der Ausgang liefert <strong>Alter</strong>. Alle erkannten Entitäten sind: 1–Jungtier, 2–erwachsen oder 15–gemischt.<br>6 – Der Ausgang liefert <strong>Art</strong>. Alle erkannten Entitäten sind: 1–Spieler, 2–Tier, 3–Wildtier, 4–Kreatur oder 15–gemischt.<br>7 – Der Ausgang liefert <strong>Fortpflanzungsstatus</strong>. Alle erkannten Entitäten sind: 1–paarungsbereit, 2–trächtig, 3–säugend oder 15–gemischt.<br>8 – Der Ausgang liefert <strong>Flags des Fortpflanzungsstatus</strong>. Bit-Flags 0–2: paarungsbereit, trächtig, säugend.<br>9 – Der Ausgang liefert <strong>Minimale Generation</strong>. Die minimal erkannte Generation ist: 0–15. Anwesende Entitäten ohne festgelegte Generation werden ignoriert.<br>10 – Der Ausgang liefert <strong>Maximale Generation</strong>. Die maximal erkannte Generation ist: 0–15. Anwesende Entitäten ohne festgelegte Generation werden ignoriert.<br>11 – Der Ausgang liefert <strong>Minimales Gewicht</strong>. Das minimal erkannte Gewicht ist: 1–verhungernd, 2–niedrig, 3–ordentlich, 4–gut. Anwesende Entitäten ohne festgelegtes Gewicht (keine Tiere) werden ignoriert.<br>12 – Der Ausgang liefert <strong>Maximales Gewicht</strong>. Das maximal erkannte Gewicht ist: 1–verhungernd, 2–niedrig, 3–ordentlich, 4–gut. Anwesende Entitäten ohne festgelegtes Gewicht (keine Tiere) werden ignoriert.<br>",
  "signalslink:block-handbooktext-managedchute": "Das gesteuerte Rohr ermöglicht den automatisierten Transport von Gegenständen zwischen verschiedenen Blöcken.",
  "signalslink:block-handbooktext-managedwallchute": "Ein in die Wand eingesetztes gesteuertes Rohr ermöglicht den automatisierten Transport von Gegenständen zwischen verschiedenen Blöcken. Es ermöglicht den Transport von Gegenständen durch Wände, was sehr nützlich für versteckte Transportsysteme oder für den Transport von Gegenständen aus dem Keller oder in den Keller sein kann, ohne dabei das kühle Kellerklima zu stören, das für die langfristige Lagerung von Lebensmitteln wichtig ist.",
  "signalslink:usageinfo-signalslink-text": "<font size=\"25\"><strong>SignalsLink</strong></font><br>Erweitert den Mod <a href=\"handbook://signals:craftinginfo-signals\">Signals</a> um weitere Komponenten.<br><br>Zum Überwachen eines Blocks in der Umgebung kannst du den <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Blocksensor</a> verwenden.<br>Wenn du deine Viehherde überwachen musst, eignet sich dafür hervorragend der <a href=\"handbook://block-signalslink:entitysensor-off-north-down\">Entitätensensor</a>.<br>Wenn du einige Arbeiten automatisieren möchtest, hilft dir das <a href=\"handbook://block-signalslink:managedchute-north-down\">gesteuerte Rohr</a> ausgezeichnet, das Gegenstände zwischen Blöcken ähnlich wie eine Rutsche transportieren kann, aber du steuerst es mit Signalen und es gibt dir viel mehr Kontrolle darüber, was transportiert wird. Seine Variante <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">gesteuertes in die Wand eingebautes Rohr</a> ermöglicht dann den Transport von Gegenständen durch Wände, was sehr nützlich für versteckte Transportsysteme oder für den Transport von Gegenständen aus dem Keller oder in den Keller sein kann, ohne dabei das kühle Kellerklima zu stören, das für die langfristige Lagerung von Lebensmitteln wichtig ist.",
  "signalslink:usageinfo-paperconditions-text": "Einige Blöcke aus dem Mod <a href=\"handbook://signalslink:usageinfo-signalslink\">SignalsLink</a> ermöglichen die Verwendung von <strong>Bedingungen auf Papier</strong>:<br>• <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Blocksensor</a><br>• <a href=\"handbook://block-signalslink:managedchute-north-down\">gesteuertes Rohr</a><br>• <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">gesteuertes in die Wand eingebautes Rohr</a><br><font size=\"20\" color=\"6082B6\">Bedingungen auf Papier</font><strong>Bedingungen auf Papier</strong> sind Bedingungen, die auf <a href=\"handbook://item-paper-parchment\">Pergament</a> geschrieben werden. Diese Bedingungen können verwendet werden, um das Verhalten eines Blocks zu beeinflussen, z.B. zur Steuerung von Ausgangssignalen oder zum Filtern von Gegenständen in Rohren.<br>Die Bedingungen werden in Blöcke (Absätze) geschrieben. Jeder Block besteht aus einer oder mehreren Zeilen, wobei in jeder Zeile eine Bedingung angegeben ist. Alle Bedingungen <strong>in einem Block</strong> werden so ausgewertet, dass zwischen ihnen der logische Operator AND angewendet wird, und das Ergebnis ergibt den Endwert des gesamten Blocks.<br>Einzelne Blöcke sind durch eine leere Zeile voneinander getrennt. Auf die Ergebniswerte der einzelnen Blöcke wird dann der logische Operator OR angewendet. Die Auswertung der einzelnen Bedingungen innerhalb eines Blocks erfolgt in der Reihenfolge von oben nach unten, wie die Bedingungen auf dem Papier angegeben sind. Die Auswertung der Blöcke erfolgt ebenfalls in der Reihenfolge, in der die Blöcke auf dem Papier stehen. Das bedeutet: Sobald ein Block als wahr (true) ausgewertet wird, wird dieses Ergebnis an den aufrufenden Block zurückgegeben und mit weiteren Blöcken nicht fortgefahren. Das ist sehr wichtig und muss berücksichtigt werden.<br><br>Wir unterscheiden mehrere Arten von Bedingungen:<br><strong>game:plank-oak</strong> – Es wird geprüft, ob der überwachte Gegenstand im Inventar oder der überwachte Block vom angegebenen Typ ist, d.h. ob sein Code exakt dem angegebenen Code entspricht. Wenn ja, gibt die Bedingung true zurück.<br><strong>game:plank-*</strong> – Es wird geprüft, ob der überwachte Gegenstand oder Block vom angegebenen Typ ist, in irgendeiner seiner Varianten (mit Sternchen gekennzeichnet). Wenn ja, gibt die Bedingung true zurück.<br><strong>@.*-plank-.*</strong> – Der Code des überwachten Gegenstands oder Blocks wird anhand dieses regulären Ausdrucks ausgewertet. Bei Übereinstimmung gibt die Bedingung true zurück.<br><strong>attribut > 1</strong> – Es wird der Wert eines Attributs des Gegenstands im Inventar oder des überwachten Blocks ausgewertet. Es können verschiedene Vergleichsoperatoren verwendet werden (größer/kleiner/gleich). Nach der Auswertung wird das Vergleichsergebnis (true/false) zurückgegeben.<br><strong>attribut</strong> – Wenn in der Bedingung nur der Name des Gegenstandsattributs angegeben ist, wird ausgewertet, ob es einen Wert hat oder nicht. D.h. Null, NULL, leerer String oder false werden als false ausgewertet. Ein nicht-null Wert, ein String oder true werden als true ausgewertet.<br><br>Auf alle Bedingungen kann der Negationsoperator <strong>!</strong> angewendet werden. Zum Beispiel wird !game:plank-oak als true ausgewertet, wenn der überwachte Gegenstand oder Block nicht exakt Eichenbretter ist.<br>Am Ende jedes Blocks kann eine Instruktion zum Setzen des Ausgangssignals hinzugefügt werden, z.B. <strong>output 1</strong>, die angibt, dass, wenn dieser Block als wahr (true) ausgewertet wird, am Ausgang Signal 1 gesendet wird. Das ist nur beim Block <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Blocksensor</a> von Bedeutung, der es ermöglicht, festzulegen, welches Signal am Ausgang gesendet wird, wenn ein Block oder Gegenstand mit den im Block angegebenen Bedingungen übereinstimmt. Bei anderen Blöcken, die Bedingungen auf Papier unterstützen, wird diese Instruktion ignoriert.<font size=\"20\" color=\"6082B6\">Einrichtung der Bedingungen</font>Du schreibst die Bedingungen auf <a href=\"handbook://item-paper-parchment\">Pergament</a>. Unterschreibe das Pergament nicht, damit du den Text später wieder bearbeiten kannst.<br>Du überträgst die Bedingungen in einen Block, der dies unterstützt, indem du mit diesem Pergament mit der rechten Maustaste auf den entsprechenden Block klickst. Die Bedingungen werden so im Block gespeichert und du siehst sie im Informationsfenster, wenn du den Block ansiehst. <br>Um die Bedingungen aus dem Block zu entfernen, nimm ein leeres Pergament in die Hand, schleiche (Shift-Taste) und klicke mit diesem leeren Pergament auf den entsprechenden Block. Damit hast du die Bedingungen aus dem Block gelöscht.<br>Wenn du Bedingungen aus einem Block auf ein leeres Pergament kopieren möchtest, klicke mit einem leeren Pergament mit der rechten Maustaste auf den entsprechenden Block, ohne zu schleichen.<br>Und schließlich eine Hilfe, um herauszufinden, welchen Code ein Block oder Gegenstand hat und welche Attribute du für Bedingungsausdrücke zur Verfügung hast:<br>Nimm den Gegenstand, der dich interessiert, in die Hand, halte die Strg-Taste gedrückt und klicke mit der rechten Maustaste mit diesem Block auf einen Block, der Bedingungen auf Papier unterstützt. Der Code des Gegenstands und seine Attribute, die für Bedingungen auf Papier verfügbar sind, werden in diesem Block gespeichert. Du kannst sie nun auf ein leeres Pergament kopieren, wie oben beschrieben, und sie hier beliebig zu Bedingungsblöcken bearbeiten und zum Einstellen des Blocks verwenden.",
  "signalslink:usageinfo-paperconditions-title": "Bedingungen auf Papier"
}
