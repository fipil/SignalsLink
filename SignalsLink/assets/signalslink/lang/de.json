{
  "game:tabname-signalslink": "Signals Link",
  "signalslink:block-blocksensor-*": "Blocksensor",
  "signals:con-input": "Eingang",
  "signals:con-output": "Ausgang",
  "signals:con-target": "Ziel",
  "signals:con-source": "Quelle",
  "signalslink:block-entitysensor-*": "Entitätensensor",
  "signals:con-x": "X",
  "signals:con-y": "Y",
  "signals:con-z": "Z",
  "signals:con-error-state": "Fehlerzustand",
  "signals:con-output1": "Ausgang 1",
  "signals:con-output2": "Ausgang 2",
  "signals:con-output1-config": "Konfiguration von Ausgang 1",
  "signals:test": "Wir testen Übersetzungen in der AI-Uhr.",
  "signals:con-output2-config": "Konfiguration von Ausgang 2",
  "signalslink:entitysensor-charged": "Geladen. {0} Einheiten hinzugefügt. Das maximale Ladungslimit beträgt {1} Einheiten.",
  "signalslink:entitysensor-already-fully-charged": "Dieses Gerät ist bereits vollständig aufgeladen.",
  "signalslink:blockinfo-charge": "Ladung: {0}/{1} Einheiten ({2}%)",
  "signalslink:blockinfo-charge-at-volume": "Bei der aktuellen Abdeckung ({0} Blöcke) kann es ungefähr {1} Tage arbeiten",
  "signalslink:blockinfo-charge-empty": "Ladung: Leer – benötigt Temporal Gear",
  "signalslink:usageinfo-signalslink-title": "SignalsLink – Erweiterung des Signals-Mods",
  "signalslink:block-managedchute-*": "Gesteuerte Rutsche",
  "signalslink:block-managedwallchute-wood-*": "Gesteuerte Rutsche in Holz eingesetzt",
  "signalslink:block-managedwallchute-rock-*": "Gesteuerte Rutsche in Stein eingesetzt",
  "signalslink:block-managedwallchute-cobble-*": "Gesteuerte Rutsche in Pflastersteinen eingesetzt",
  "signalslink:managedchute-conditions": "Bedingungen",
  "signalslink:managedchute-info-unlimited": "Transportiert dauerhaft",
  "signalslink:managedchute-info-remaining": "Transportiert {0}",
  "signalslink:block-handbooktitle-signalslink": "Signalfunktionen",
  "signalslink:block-handbooktext-blocksensor": "    Der Blocksensor erkennt die Anwesenheit eines Blocks an der gewählten benachbarten Position und liefert je nach Blocktyp bzw. Eingangssignal am Ausgang Informationen über dessen Zustand oder die Belegung der Slots.    <br>    <font size=\"20\" color=\"6082B6\">Die bislang unterstützten Blöcke sind:<\\/font>    <br>    <strong>Amboss<\\/strong> - Wenn sich auf dem Amboss ein ausreichend erhitzter Barren zum Schmieden befindet, liegt am Ausgang Signal 1 an. Andernfalls wird Signal 0 ausgegeben.    <br>    <strong>Türen, Zäune, Falltüren<\\/strong> - Bei Türen und Zauntoren muss der Block am Boden auf der Scharnierseite überwacht werden. Ist der Block geöffnet, liegt am Ausgang Signal 1 an, ist er geschlossen, liegt am Ausgang Signal 0 an.    <br>    <strong>Truhe oder allgemein Container oder beliebige Blöcke, die Inventarslots besitzen<\\/strong> (z. B. Feuerstelle, Fass, Trog usw.). Am Ausgang liegt ein Signal entsprechend dem Eingangssignal an.    <br>    Das Eingangssignal bestimmt, welcher Slot gescannt werden soll.    <br>    Signal 1–14 entsprechen den Slots 0–13. Der Ausgang liefert die Information über die Belegung des Slots im Verhältnis zur maximalen Stapelgröße des Items in diesem Slot, umgerechnet auf ein Signal von 0–15.    <br>    Signal 15 bewirkt, dass der Sensor die gesamte Belegung aller Slots erkennt, z. B. einer ganzen Truhe.    <br>    <strong>Irgendein anderer Block, der oben nicht genannt ist<\\/strong> - Befindet sich im überwachten Bereich nichts (Luft), liegt am Ausgang Signal 0 an. Befindet sich dort Wasser, liegt am Ausgang 2 – Süßwasser oder 3 – Salzwasser an. Befindet sich dort irgendein anderer Block, liegt am Ausgang Signal 1 an.    <br>",
  "signalslink:block-handbooktext-entitysensor": "    Der Entitätensensor erkennt die Anwesenheit von Entitäten (Spielern, Tieren, Wildtieren oder Monstern) im markierten Bereich und kann an den Ausgängen Informationen über deren Anzahl, Typ oder Zustand liefern. Für seinen Betrieb benötigt der Sensor eine Aufladung mit einem oder mehreren Zeiträdern (Temporal Gears). Die Verbrauchsrate hängt dann von der Größe des überwachten Bereichs ab.    <br>    Die Eingänge <strong>x, y, z<\\/strong> bestimmen die Größe des überwachten Bereichs in Blöcken.    <br>    Am Ausgang <strong>Fehler<\\/strong> liegt Signal 1 an, wenn der Sensor entladen ist, sonst 0.    <br>    Die Eingänge <strong>Ausgabe 1 einstellen<\\/strong> und <strong>Ausgabe 2 einstellen<\\/strong> bestimmen, welche Informationen an den Ausgängen 1 und 2 bereitgestellt werden. An jedem Ausgang können Sie anhand der Einstellung dieser Eingänge eine andere Information erhalten.    <br>    Die Möglichkeiten sind:    <br>    1 - Der Ausgang liefert die <strong>Anzahl<\\/strong>. Anzahl der erkannten Entitäten.    <br>    2 - Der Ausgang liefert die <strong>Kategorie<\\/strong>. Bit‑Flags der Entitätenkategorie 0–3: Spieler, Kreatur, Tier, Wildtier.    <br>    3 - Der Ausgang liefert den <strong>Lebenszustand<\\/strong>. Alle erkannten Entitäten sind: 1 – tot, 2 – lebendig oder 15 – gemischt.    <br>    4 - Der Ausgang liefert das <strong>Geschlecht<\\/strong>. Alle erkannten Entitäten sind: 1 – männlich, 2 – weiblich oder 15 – gemischt.    <br>    5 - Der Ausgang liefert das <strong>Alter<\\/strong>. Alle erkannten Entitäten sind: 1 – Jungtier, 2 – erwachsen oder 15 – gemischt.    <br>    6 - Der Ausgang liefert die <strong>Art<\\/strong>. Alle erkannten Entitäten sind: 1 – Spieler, 2 – Tier, 3 – Wildtier, 4 – Kreatur oder 15 – gemischt.    <br>    7 - Der Ausgang liefert den <strong>Reproduktionszustand<\\/strong>. Alle erkannten Entitäten sind: 1 – paarungsbereit, 2 – trächtig, 3 – säugend oder 15 – gemischt.    <br>    8 - Der Ausgang liefert die <strong>Flags des Reproduktionszustands<\\/strong>. Bit‑Flags 0–2: paarungsbereit, trächtig, säugend.    <br>    9 - Der Ausgang liefert die <strong>minimale Generation<\\/strong>. Die minimal erkannte Generation ist: 0–15. Vorhandene Entitäten ohne Generation werden ignoriert.    <br>    10 - Der Ausgang liefert die <strong>maximale Generation<\\/strong>. Die maximal erkannte Generation ist: 0–15. Vorhandene Entitäten ohne Generation werden ignoriert.    <br>    11 - Der Ausgang liefert das <strong>minimale Gewicht<\\/strong>. Das minimal erkannte Gewicht ist: 1 – ausgehungert, 2 – niedrig, 3 – ordentlich, 4 – gut. Vorhandene Entitäten ohne Gewichtsangabe (keine Tiere) werden ignoriert.    <br>    12 - Der Ausgang liefert das <strong>maximale Gewicht<\\/strong>. Das maximal erkannte Gewicht ist: 1 – ausgehungert, 2 – niedrig, 3 – ordentlich, 4 – gut. Vorhandene Entitäten ohne Gewichtsangabe (keine Tiere) werden ignoriert.    <br>",
  "signalslink:block-handbooktext-managedchute": "    Das gesteuerte Rohr ermöglicht den automatisierten Transport von Gegenständen zwischen verschiedenen Blöcken.",
  "signalslink:block-handbooktext-managedwallchute": "    Das in die Wand eingelassene gesteuerte Rohr ermöglicht den automatisierten Transport von Gegenständen zwischen verschiedenen Blöcken. Es erlaubt den Transport von Gegenständen durch Wände, was sehr nützlich für versteckte Transportsysteme sein kann oder für den Transport von Gegenständen aus dem Keller oder in den Keller, ohne dabei das kühle Kellerklima zu beeinträchtigen, das für die langfristige Lagerung von Lebensmitteln wichtig ist.",
  "signalslink:usageinfo-signalslink-text": "    <font size=\"25\"><strong>SignalsLink<\\/strong><\\/font>    <br>    Erweitert das Mod <a href=\"handbook://signals:craftinginfo-signals\">Signals<\\/a> um weitere Komponenten.    <br>    <br>    Zur Überwachung eines Blocks in der Umgebung können Sie den <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Blocksensor<\\/a> verwenden.    <br>    Wenn Sie Ihre Viehherde überwachen müssen, eignet sich dafür hervorragend der <a href=\"handbook://block-signalslink:entitysensor-off-north-down\">Entitätensensor<\\/a>.    <br>    Wenn Sie bestimmte Arbeiten automatisieren möchten, leistet Ihnen das <a href=\"handbook://block-signalslink:managedchute-north-down\">gesteuerte Rohr<\\/a> hervorragende Dienste, das Gegenstände zwischen Blöcken ähnlich wie eine Rutsche transportieren kann, aber von Signalen gesteuert wird und Ihnen viel mehr Kontrolle darüber gibt, was transportiert wird. Seine Variante, das <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">in die Wand eingebaute gesteuerte Rohr<\\/a>, ermöglicht dann den Transport von Gegenständen durch Wände, was sehr nützlich für versteckte Transportsysteme sein kann oder für den Transport von Gegenständen aus dem Keller oder in den Keller, ohne dabei das kühle Kellerklima zu beeinträchtigen, das für die langfristige Lagerung von Lebensmitteln wichtig ist.",
  "signalslink:usageinfo-paperconditions-text": "    Einige Blöcke aus dem Mod <a href=\"handbook://signalslink:usageinfo-signalslink\">SignalsLink<\\/a> erlauben die Verwendung von <strong>Bedingungen auf Pergament<\\/strong>:    <br>    • <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Blocksensor<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedchute-north-down\">Gesteuertes Rohr<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">In die Wand eingebautes gesteuertes Rohr<\\/a>    <br>    <font size=\"20\" color=\"6082B6\">Bedingungen auf Pergament<\\/font>    <strong>Bedingungen auf Pergament<\\/strong> sind Bedingungen, die auf <a href=\"handbook://item-paper-parchment\">Pergament<\\/a> geschrieben werden. Diese Bedingungen können verwendet werden, um das Verhalten eines Blocks zu beeinflussen, z. B. zur Steuerung der Ausgangssignale oder zum Filtern von Gegenständen in Rohren.    <br>    Die Bedingungen werden in Blöcke (Absätze) geschrieben. Jeder Block besteht aus einer oder mehreren Zeilen, wobei in jeder Zeile eine Bedingung angegeben wird. Alle Bedingungen <strong>in einem Block<\\/strong> werden so ausgewertet, dass zwischen ihnen der logische Operator UND angewendet wird, und das Ergebnis ergibt den Gesamtwert des gesamten Blocks.    <br>    Die einzelnen Blöcke werden durch eine Leerzeile voneinander getrennt. Auf die Ergebniswerte der einzelnen Blöcke wird dann der logische Operator ODER angewendet. Die Auswertung der einzelnen Bedingungen in einem Block erfolgt in der Reihenfolge von oben nach unten, wie die Bedingungen auf dem Pergament aufgeführt sind. Die Auswertung der Blöcke erfolgt ebenfalls in der Reihenfolge, in der die Blöcke auf dem Pergament aufgeführt sind. Das bedeutet, dass sobald ein Block als wahr (true) ausgewertet wird, dieses Ergebnis an den aufrufenden Block zurückgegeben wird und mit dem nächsten Block nicht mehr fortgefahren wird. Dies ist sehr wichtig, und man muss damit rechnen.    <br>    <br>    Wir unterscheiden mehrere Arten von Bedingungen:    <br>    <strong>game:plank-oak<\\/strong> - Es wird ausgewertet, ob der überwachte Gegenstand im Inventar oder der überwachte Block vom angegebenen Typ ist, d. h. ob sein Code genau dem angegebenen Code entspricht. Wenn ja, gibt die Bedingung true zurück.<br>    <strong>game:plank-*<\\/strong> - Es wird ausgewertet, ob der überwachte Gegenstand oder Block vom angegebenen Typ in einer beliebigen Variante ist (mit Sternchen gekennzeichnet). Wenn ja, gibt die Bedingung true zurück.<br>    <strong>@.*-plank-.*<\\/strong> - Der Code des überwachten Gegenstands oder Blocks wird mit diesem regulären Ausdruck ausgewertet. Wenn eine Übereinstimmung vorliegt, gibt die Bedingung true zurück.<br>    <strong>attribut > 1<\\/strong> - Es wird der Wert eines Attributs des Gegenstands im Inventar oder des überwachten Blocks ausgewertet. Hier können verschiedene Vergleichsoperatoren verwendet werden (größer/kleiner/gleich). Nach der Auswertung wird das Ergebnis des Vergleichs (true/false) zurückgegeben.<br>    <strong>attribut<\\/strong> - Wenn in der Bedingung nur der Name des Attributs des Gegenstands angegeben wird, wird ausgewertet, ob es einen Wert hat oder nicht. D. h. Null, NULL, leerer String oder false werden als false ausgewertet. Ein von Null verschiedener Wert, ein String oder true werden als true ausgewertet.<br>    <br>    Auf alle Bedingungen kann der Negationsoperator <strong>!<\\/strong> angewendet werden. Zum Beispiel wird !game:plank-oak als true ausgewertet, wenn der überwachte Gegenstand oder Block nicht genau Eichenbretter ist.    <br>    An das Ende jedes Blocks kann eine Anweisung zum Setzen des Ausgangssignals angefügt werden, z. B. <strong>output 1<\\/strong>, die bestimmt, dass, wenn dieser Block als wahr (true) ausgewertet wird, am Ausgang Signal 1 ausgegeben wird. Dies ist nur beim Block <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Blocksensor<\\/a> von Bedeutung, der es ermöglicht festzulegen, welches Signal am Ausgang gesendet wird, wenn ein Block oder Gegenstand mit den im Block angegebenen Bedingungen übereinstimmt. Bei anderen Blöcken, die die Verwendung von Bedingungen auf Pergament erlauben, wird diese Anweisung ignoriert.    <font size=\"20\" color=\"6082B6\">Einstellung der Bedingungen<\\/font>    Die Bedingungen schreiben Sie auf ein <a href=\"handbook://item-paper-parchment\">Pergament<\\/a>. Unterzeichnen Sie das Pergament nicht, damit Sie den Text später erneut bearbeiten können.<br>    Sie übertragen die Bedingungen in einen Block, der dies unterstützt, indem Sie mit diesem Pergament mit der rechten Maustaste auf den entsprechenden Block klicken. Die Bedingungen werden so im Block gespeichert, und Sie sehen sie im Informationsfenster, wenn Sie den Block ansehen. <br>    Um die Bedingungen aus einem Block zu entfernen, nehmen Sie ein leeres Pergament in die Hand, hocken sich (Shift‑Taste) und klicken mit diesem leeren Pergament auf den betreffenden Block. Damit haben Sie die Bedingungen aus dem Block gelöscht.<br>    Wenn Sie die Bedingungen aus einem Block auf ein leeres Pergament kopieren möchten, klicken Sie mit einem leeren Pergament mit der rechten Maustaste auf den Block, ohne sich zu hocken.<br>    Und zum Schluss eine Hilfe, um herauszufinden, welchen Code ein bestimmter Block oder Gegenstand hat und welche Attribute Ihnen für die Verwendung in Bedingungsausdrücken zur Verfügung stehen:<br>    Nehmen Sie den Gegenstand, der Sie interessiert, in die Hand, halten Sie die Strg‑Taste gedrückt und klicken Sie mit diesem Block mit der rechten Maustaste auf einen Block, der Bedingungen auf Pergament unterstützt. Der Code des Gegenstands und seine für Bedingungen auf Pergament verfügbaren Attribute werden in diesem Block gespeichert. Sie können sie nun, wie oben beschrieben, auf ein leeres Pergament kopieren und dort nach Belieben in Bedingungsblöcke umarbeiten und zur Einstellung des Blocks verwenden.",
  "signalslink:usageinfo-paperconditions-title": "Bedingungen auf Pergament"
}
