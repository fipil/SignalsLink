{
  "game:tabname-signalslink": "Signals Link",
  "signalslink:block-blocksensor-*": "Blocksensor",
  "signals:con-input": "Eingang",
  "signals:con-output": "Ausgang",
  "signals:con-target": "Ziel",
  "signals:con-source": "Quelle",
  "signalslink:block-entitysensor-*": "Wesensensor",
  "signals:con-x": "X",
  "signals:con-y": "Y",
  "signals:con-z": "Z",
  "signals:con-error-state": "Fehlerzustand",
  "signals:con-output1": "Ausgang 1",
  "signals:con-output2": "Ausgang 2",
  "signals:con-output1-config": "Einstellungen für Ausgang 1",
  "signals:test": "Wir testen Übersetzungen in der KI-Stunde.",
  "signals:con-output2-config": "Einstellungen für Ausgang 2",
  "signalslink:entitysensor-charged": "Aufgeladen. {0} Einheiten hinzugefügt. Das maximale Ladelimit beträgt {1} Einheiten.",
  "signalslink:entitysensor-already-fully-charged": "Dieses Gerät ist bereits vollständig aufgeladen.",
  "signalslink:blockinfo-charge": "Ladung: {0}/{1} Einheiten ({2}%)",
  "signalslink:blockinfo-charge-at-volume": "Bei der aktuellen Abdeckung ({0} Blöcke) kann es arbeiten für: ~{1} Tage",
  "signalslink:blockinfo-charge-empty": "Ladung: Leer - benötigt Temporal Gear",
  "signalslink:usageinfo-signalslink-title": "SignalsLink - Erweiterung des Mods Signals",
  "signalslink:block-managedchute-*": "Gesteuerte Röhre",
  "signalslink:block-managedwallchute-wood-*": "Gesteuerte Röhre in Holz eingelassen",
  "signalslink:block-managedwallchute-rock-*": "Gesteuerte Röhre in Fels eingelassen",
  "signalslink:block-managedwallchute-cobble-*": "Gesteuerte Röhre in Pflaster eingelassen",
  "signalslink:managedchute-conditions": "Bedingungen",
  "signalslink:managedchute-info-unlimited": "Transportiert dauerhaft",
  "signalslink:managedchute-info-remaining": "Transportiert {0}",
  "signalslink:block-handbooktitle-signalslink": "Signalfunktionen",
  "signalslink:block-handbooktext-blocksensor": "    Der Blocksensor erkennt die Anwesenheit eines Blocks auf der ausgewählten benachbarten Position und liefert abhängig von seinem Typ bzw. vom Eingangssignal am Ausgang Informationen über seinen Zustand oder die Belegung der Slots.    <br>    <font size=\"20\" color=\"6082B6\">Derzeit unterstützte Blöcke sind:<\\/font>    <br>    <strong>Amboss<\\/strong> - Wenn sich auf dem Amboss ein ausreichend glühender Barren zum Schmieden befindet, liegt am Ausgang Signal 1 an. Andernfalls sendet er Signal 0.    <br>    <strong>Türen, Tore, Klappen<\\/strong> - Bei Türen und Toren muss der Block am Boden auf der Seite der Scharniere überwacht werden. Ist der Block geöffnet, liegt am Ausgang Signal 1 an, ist er geschlossen, liegt am Ausgang Signal 0 an.    <br>    <strong>Truhe oder allgemein ein Container oder beliebige Blöcke, die Inventar-Slots haben<\\/strong> (z.B. Feuerstelle, Fass, Trog usw.). Am Ausgang liegt ein Signal entsprechend dem Eingangssignal an.    <br>    Das Eingangssignal bestimmt, welcher Slot gescannt werden soll.    <br>    Signal 1-14 bestimmt die Slots 0-13. Der Ausgang ist die Information über die Füllung des Slots relativ zur maximalen Stapelkapazität des Gegenstands in diesem Slot, umgerechnet in ein Signal 0-15.    <br>    Signal 15 bestimmt, dass der Sensor die Gesamtfüllung aller Slots erkennen soll, z.B. einer ganzen Truhe.    <br>    <strong>Ein anderer Block, oben nicht aufgeführt<\\/strong> - Wenn sich im überwachten Raum nichts befindet (es ist Luft), liegt am Ausgang Signal 0 an. Befindet sich dort Wasser, liegt am Ausgang 2 - Süßwasser oder 3 - Salzwasser an. Befindet sich dort irgendein anderer Block, liegt am Ausgang Signal 1 an.    <br>",
  "signalslink:block-handbooktext-entitysensor": "    Der Entitätensensor erkennt die Anwesenheit von Entitäten (Spielern, Tieren, Wildtieren oder Monstern) im markierten Bereich und kann an den Ausgängen Informationen über deren Anzahl, Typ oder Zustand bereitstellen. Für den Betrieb benötigt der Sensor eine Ladung    durch ein oder mehrere Zeiträdchen (Temporal gears). Die Verbrauchsgeschwindigkeit hängt dann von der Größe des überwachten Bereichs ab.    <br>    <strong>Eingänge x, y, z<\\/strong> bestimmen die Größe des überwachten Bereichs in Blöcken.    <br>    Am Ausgang <strong>Fehler<\\/strong> liegt Signal 1 an, wenn der Sensor entladen ist, sonst 0.    <br>    Die Eingänge <strong>Ausgang 1 einstellen<\\/strong> und <strong>Ausgang 2 einstellen<\\/strong> bestimmen, welche Informationen an den Ausgängen 1 und 2 bereitgestellt werden. An jedem Ausgang können Sie so je nach Einstellung dieser Eingänge andere Informationen erhalten.    <br>    Die Möglichkeiten sind:    <br>    1 - Der Ausgang liefert <strong>Anzahl<\\/strong>. Anzahl der erkannten Entitäten.    <br>    2 - Der Ausgang liefert <strong>Kategorie<\\/strong>. Bit-Flags der Entitätskategorie 0–3: Spieler, Kreatur, Tier, Wildtier.    <br>    3 - Der Ausgang liefert <strong>Lebenszustand<\\/strong>. Alle erkannten Entitäten sind: 1–tot, 2–lebendig oder 15–gemischt.    <br>    4 - Der Ausgang liefert <strong>Geschlecht<\\/strong>. Alle erkannten Entitäten sind: 1–männlich, 2–weiblich oder 15–gemischt.    <br>    5 - Der Ausgang liefert <strong>Alter<\\/strong>. Alle erkannten Entitäten sind: 1–Jungtier, 2–erwachsen oder 15–gemischt.    <br>    6 - Der Ausgang liefert <strong>Art<\\/strong>. Alle erkannten Entitäten sind: 1–Spieler, 2–Tier, 3–Wildtier, 4–Kreatur oder 15–gemischt.    <br>    7 - Der Ausgang liefert <strong>Fortpflanzungszustand<\\/strong>. Alle erkannten Entitäten sind: 1–paarungsbereit, 2–trächtig, 3–säugend oder 15–gemischt.    <br>    8 - Der Ausgang liefert <strong>Flags des Fortpflanzungszustands<\\/strong>. Bit-Flags 0–2: paarungsbereit, trächtig, säugend.    <br>    9 - Der Ausgang liefert <strong>Minimale Generation<\\/strong>. Die minimale erkannte Generation ist: 0–15. Vorhandene Entitäten ohne Generationsangabe werden ignoriert.    <br>    10 - Der Ausgang liefert <strong>Maximale Generation<\\/strong>. Die maximale erkannte Generation ist: 0–15. Vorhandene Entitäten ohne Generationsangabe werden ignoriert.    <br>    11 - Der Ausgang liefert <strong>Minimales Gewicht<\\/strong>. Das minimale erkannte Gewicht ist: 1–verhungernd, 2–niedrig, 3–ordentlich, 4–gut. Vorhandene Entitäten ohne Gewichtsangabe (sind keine Tiere) werden ignoriert.    <br>    12 - Der Ausgang liefert <strong>Maximales Gewicht<\\/strong>. Das maximale erkannte Gewicht ist: 1–verhungernd, 2–niedrig, 3–ordentlich, 4–gut. Vorhandene Entitäten ohne Gewichtsangabe (sind keine Tiere) werden ignoriert.    <br>",
  "signalslink:block-handbooktext-managedchute": "    Die gesteuerte Rutsche ermöglicht den automatisierten Transport von Gegenständen zwischen verschiedenen Blöcken.",
  "signalslink:block-handbooktext-managedwallchute": "    Eine in die Wand eingelassene gesteuerte Rutsche ermöglicht den automatisierten Transport von Gegenständen zwischen verschiedenen Blöcken. Sie ermöglicht den Transport von Gegenständen durch Wände, was sehr nützlich sein kann für versteckte Transportsysteme    oder für den Transport von Gegenständen aus dem Keller oder in den Keller, ohne dabei die kühle Kellerumgebung zu beeinträchtigen, die für die langfristige Lagerung von Lebensmitteln wichtig ist.",
  "signalslink:usageinfo-signalslink-text": "    <font size=\"25\"><strong>SignalsLink<\\/strong><\\/font>    <br>    Erweitert die Mod <a href=\"handbook://signals:craftinginfo-signals\">Signals<\\/a> um weitere Komponenten.    <br>    <br>    Zum Überwachen eines Blocks in der Umgebung können Sie den <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Blocksensor<\\/a> verwenden.    <br>    Wenn Sie Ihre Viehherde überwachen müssen, eignet sich dafür hervorragend der <a href=\"handbook://block-signalslink:entitysensor-off-north-down\">Entitätensensor<\\/a>.    <br>    Wenn Sie einige Arbeiten automatisieren möchten, leistet Ihnen die <a href=\"handbook://block-signalslink:managedchute-north-down\">gesteuerte Rutsche<\\/a> ausgezeichnete Dienste, die Gegenstände zwischen Blöcken ähnlich wie eine Rutsche transportieren kann, aber Sie steuern sie mit Signalen und sie gibt Ihnen    viel mehr Kontrolle darüber, was transportiert wird. Ihre Variante <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">in die Wand eingebaute gesteuerte Rutsche<\\/a> ermöglicht dann den Transport von Gegenständen durch Wände, was sehr nützlich sein kann für versteckte Transportsysteme    oder für den Transport von Gegenständen aus dem Keller oder in den Keller, ohne dabei die kühle Kellerumgebung zu beeinträchtigen, die für die langfristige Lagerung von Lebensmitteln wichtig ist.",
  "signalslink:usageinfo-paperconditions-text": "    Einige Blöcke aus der Mod <a href=\"handbook://signalslink:usageinfo-signalslink\">SignalsLink<\\/a> ermöglichen die Verwendung von <strong>Bedingungen auf Papier<\\/strong>:    <br>    • <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Blocksensor<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedchute-north-down\">gesteuerte Rutsche<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">in die Wand eingebaute gesteuerte Rutsche<\\/a>    <br>    <font size=\"20\" color=\"6082B6\">Bedingungen auf Papier<\\/font>    <strong>Bedingungen auf Papier<\\/strong> sind Bedingungen, die auf <a href=\"handbook://item-paper-parchment\">Pergament<\\/a> geschrieben sind. Diese Bedingungen können verwendet werden, um das Verhalten eines Blocks zu beeinflussen, zum Beispiel zur Steuerung von Ausgangssignalen oder zum Filtern von Gegenständen in Rutschen.    <br>    Die Bedingungen werden in Blöcke (Absätze) geschrieben. Jeder Block besteht aus einer oder mehreren Zeilen, wobei in jeder Zeile eine Bedingung angegeben ist. Alle Bedingungen <strong>in einem Block<\\/strong> werden so ausgewertet, dass zwischen ihnen der logische Operator AND angewendet wird    und das Ergebnis den Endwert des gesamten Blocks ergibt.    <br>    Einzelne Blöcke sind durch eine leere Zeile voneinander getrennt. Auf die Ergebniswerte der einzelnen Blöcke wird dann der logische Operator OR angewendet. Die Auswertung der einzelnen Bedingungen im Block erfolgt in der Reihenfolge von oben nach unten, wie die Bedingungen auf dem Papier stehen.    Die Auswertung der Blöcke erfolgt ebenfalls in der Reihenfolge, in der die Blöcke auf dem Papier stehen. Das bedeutet, dass sobald ein Block als wahr (true) ausgewertet wird, dieses Ergebnis an den aufrufenden Block zurückgegeben wird und mit dem nächsten Block nicht weitergemacht wird.    Dies ist sehr wichtig und man muss damit rechnen.    <br>    <br>    Wir unterscheiden mehrere Arten von Bedingungen:    <br>    <strong>game:plank-oak<\\/strong> - Es wird ausgewertet, ob der beobachtete Gegenstand im Inventar oder der beobachtete Block vom angegebenen Typ ist, d.h. sein Code entspricht genau dem angegebenen Code. Wenn ja, gibt die Bedingung true zurück.<br>    <strong>game:plank-*<\\/strong> - Es wird ausgewertet, ob der beobachtete Gegenstand oder Block vom angegebenen Typ ist, in beliebiger Variante (mit Sternchen gekennzeichnet). Wenn ja, gibt die Bedingung true zurück.<br>    <strong>@.*-plank-.*<\\/strong> - Der Code des beobachteten Gegenstands oder Blocks wird mit diesem regulären Ausdruck ausgewertet. Bei Übereinstimmung gibt die Bedingung true zurück.<br>    <strong>attribut > 1<\\/strong> - Es wird der Wert eines Attributs des Gegenstands im Inventar oder des beobachteten Blocks ausgewertet. Es können verschiedene Vergleichsoperatoren verwendet werden (größer/kleiner/gleich). Nach der Auswertung wird das Ergebnis des Vergleichs (true/false) zurückgegeben.<br>    <strong>attribut<\\/strong> - Wenn in der Bedingung nur der Name des Attributs angegeben wird, wird ausgewertet, ob es einen Wert hat oder nicht. D.h. Null, NULL, leerer String oder false wird als false ausgewertet. Ein nichtnull Wert, String oder true wird als true ausgewertet.<br>    <br>    Auf alle Bedingungen kann der Negationsoperator <strong>!<\\/strong> angewendet werden. Zum Beispiel wird !game:plank-oak als true ausgewertet, wenn der beobachtete Gegenstand oder Block nicht genau Eichenbretter ist.    <br>    Am Ende jedes Blocks kann eine Instruktion zum Setzen des Ausgangssignals hinzugefügt werden, z.B. <strong>output 1<\\/strong>, die angibt, dass wenn dieser Block als wahr (true) ausgewertet wird, am Ausgang Signal 1 gesendet wird.    Dies hat Bedeutung nur beim Block <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Blocksensor<\\/a>, der ermöglicht einzustellen, welches Signal am Ausgang gesendet wird, falls ein Block oder Gegenstand mit den in dem Block angegebenen Bedingungen übereinstimmt. Bei den anderen Blöcken, die die Verwendung von Bedingungen auf Papier erlauben, wird diese Instruktion ignoriert.    <font size=\"20\" color=\"6082B6\">Einrichtung der Bedingungen<\\/font>    Schreiben Sie die Bedingungen auf <a href=\"handbook://item-paper-parchment\">Pergament<\\/a>. Unterschreiben Sie das Pergament nicht, damit Sie den Text später wieder bearbeiten können.<br>    Übertragen Sie die Bedingungen in einen Block, der dies unterstützt, indem Sie mit diesem Pergament mit der rechten Maustaste auf den betreffenden Block klicken. Die Bedingungen werden so im Block gespeichert und Sie sehen sie im Informationsfenster, wenn Sie den Block ansehen. <br>    Um die Bedingungen aus einem Block zu entfernen, nehmen Sie ein leeres Pergament in die Hand, ducken Sie sich (Shift-Taste) und klicken Sie mit diesem leeren Pergament auf den betreffenden Block. Damit haben Sie die Bedingungen aus dem Block gelöscht.<br>    Wenn Sie die Bedingungen aus einem Block auf ein leeres Pergament kopieren möchten, klicken Sie mit einem leeren Pergament mit der rechten Maustaste auf den betreffenden Block, ohne sich zu ducken.<br>    Und schließlich eine Hilfe, um herauszufinden, welchen Code ein Block oder Gegenstand hat und welche Attribute Sie für die Verwendung in Bedingungsausdrücken zur Verfügung haben:<br>    Nehmen Sie den Gegenstand, der Sie interessiert, in die Hand, halten Sie die Strg-Taste gedrückt und klicken Sie mit der rechten Maustaste mit diesem Block auf einen Block, der Bedingungen auf Papier unterstützt. Der Code des Gegenstands und seine Attribute, die für Bedingungen auf Papier verfügbar sind, werden in diesen Block gespeichert. Sie können sie nun auf ein     leeres Pergament kopieren, wie oben beschrieben, und hier beliebig zu Bedingungsblöcken bearbeiten und sie zum Einstellen des Blocks verwenden.",
  "signalslink:usageinfo-paperconditions-title": "Bedingungen auf Papier"
}
