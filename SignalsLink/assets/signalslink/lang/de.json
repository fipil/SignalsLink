{
  "game:tabname-signalslink": "Signals Link",
  "signalslink:block-blocksensor-*": "Blocksensor",
  "signals:con-input": "Eingang",
  "signals:con-output": "Ausgang",
  "signals:con-target": "Ziel",
  "signals:con-source": "Quelle",
  "signalslink:block-entitysensor-*": "Wesenssensor",
  "signals:con-x": "X",
  "signals:con-y": "Y",
  "signals:con-z": "Z",
  "signals:con-error-state": "Fehlerzustand",
  "signals:con-output1": "Ausgang 1",
  "signals:con-output2": "Ausgang 2",
  "signals:con-output1-config": "Ausgang 1 konfigurieren",
  "signals:test": "Wir testen Übersetzungen in der KI-Stunde.",
  "signals:con-output2-config": "Ausgang 2 konfigurieren",
  "signalslink:entitysensor-charged": "Aufgeladen. {0} Einheiten hinzugefügt. Das maximale Aufladelimit beträgt {1} Einheiten.",
  "signalslink:entitysensor-already-fully-charged": "Dieses Gerät ist bereits vollständig aufgeladen.",
  "signalslink:blockinfo-charge": "Ladung: {0}/{1} Einheiten ({2}%)",
  "signalslink:blockinfo-charge-at-volume": "Bei aktueller Abdeckung ({0} Blöcke) reicht es zum Arbeiten für: ~{1} Tage",
  "signalslink:blockinfo-charge-empty": "Ladung: Leer - benötigt ein Temporal Gear",
  "signalslink:usageinfo-signalslink-title": "SignalsLink - Erweiterung des Mods Signals",
  "signalslink:block-managedchute-*": "Gesteuertes Rohr",
  "signalslink:block-managedwallchute-wood-*": "Gesteuertes Rohr in Holz eingesetzt",
  "signalslink:block-managedwallchute-rock-*": "Gesteuertes Rohr in Fels eingesetzt",
  "signalslink:block-managedwallchute-cobble-*": "Gesteuertes Rohr in Fliesen eingesetzt",
  "signalslink:managedchute-conditions": "Bedingungen",
  "signalslink:managedchute-info-unlimited": "Transportiert dauerhaft",
  "signalslink:managedchute-info-remaining": "Transportiert {0}",
  "signalslink:block-handbooktitle-signalslink": "Verwendung",
  "signalslink:block-handbooktext-blocksensor": "Der Blocksensor erkennt die Anwesenheit eines Blocks an der ausgewählten benachbarten Position und liefert abhängig von seinem Typ bzw. vom Eingangssignal am Ausgang eine Information über seinen Zustand oder die Belegung der Slots. <br> <font size=\"20\" color=\"6082B6\">Derzeit unterstützte Blöcke sind:</font> <br> <strong>Amboss</strong> - wenn sich auf dem Amboss ein ausreichend heißer Ingot zum Schmieden befindet, liegt am Ausgang Signal 1 an. Andernfalls sendet er Signal 0. <br> <strong>Türen, Tore, Falltüren</strong> - Bei Türen und Toren muss der Block am Boden auf der Scharnierseite überwacht werden. Ist der Block geöffnet, liegt am Ausgang Signal 1 an, ist er geschlossen, liegt am Ausgang Signal 0 an. <br> <strong>Truhe oder allgemein ein Behälter oder beliebige Blöcke, die Inventar-Slots haben</strong> (z.B. Feuerstelle, Fass, Trog o.ä.). Am Ausgang liegt ein Signal entsprechend dem Eingangssignal an. <br> Das Eingangssignal bestimmt, welcher Slot gescannt werden soll. <br> Signal 1-14 bestimmt die Slots 0-13. Die Ausgabe ist eine Information über die Belegung des Slots relativ zur maximalen Stack-Kapazität des Gegenstands in diesem Slot, umgerechnet in ein Signal 0-15. <br> Signal 15 bestimmt, dass der Sensor die Gesamtfüllung aller Slots erkennen soll, z.B. einer ganzen Truhe. <br> <strong>Ein anderer Block, der oben nicht aufgeführt ist</strong> - Wenn sich im überwachten Bereich nichts befindet (dort ist Luft), liegt am Ausgang Signal 0 an. Wenn dort Wasser ist, liegt am Ausgang 2-Süßwasser oder 3-Salzwasser an. Wenn dort irgendein anderer Block ist, liegt am Ausgang Signal 1 an. <br><br> <font size=\"20\" color=\"6082B6\">Bedingungen auf Papier</font><br> <a href=\"handbook://signalslink:usageinfo-paperconditions\">Bedingungen auf Papier</a> sind beim Blocksensor relevant, wenn Behälter oder allgemein Blöcke mit Inventar überwacht werden. <strong>Wenn ihr Bedingungen auf Papier eingestellt habt, ändert sich das Verhalten des Blocksensors wie folgt</strong>: Wenn ihr einen bestimmten Slot überwacht (Signal am Eingang 1-14), werden die Bedingungen auf den Gegenstand in diesem Slot angewendet und, falls er mit den Bedingungen übereinstimmt, wird das Signal zurückgegeben, das in der Anweisung <strong>output</strong> im Bedingungsblock eingestellt ist, in dem die Übereinstimmung gefunden wurde. Ist <strong>output</strong> nicht angegeben, wird Signal 15 zurückgegeben.<br> Wenn ihr die Gesamtfüllung des Inventars überwacht (Signal am Eingang 15), werden die Bedingungen auf alle Gegenstände in allen überwachten Slots angewendet. Sobald ein Gegenstand mit den Bedingungen übereinstimmt, wird das Signal zurückgegeben, das in der Anweisung <strong>output</strong> im Bedingungsblock eingestellt ist, in dem die Übereinstimmung gefunden wurde. Ist die Anweisung <strong>output</strong> in den Bedingungen nicht angegeben, wird die Nummer des ersten Slots zurückgegeben, in dem eine Übereinstimmung gefunden wurde.<br> <strong>Tipp:</strong> Das könnt ihr verwenden, um die Slot-Nummer herauszufinden. Legt den Gegenstand in den Slot, dessen Nummer ihr kennen wollt. Lasst die anderen Slots leer und überwacht dann diesen Block mit dem Blocksensor, auf den ihr die Bedingungen auf Papier \"*\" anwendet, und sendet an seinen Eingang Signal 15. Am Ausgang erscheint dann das Signal mit der Slot-Nummer, in der sich der Gegenstand befindet.<br> Wenn kein Gegenstand in den Slots mit Bedingungen auf Papier übereinstimmt, wird Signal 0 zurückgegeben. ",
  "signalslink:block-handbooktext-entitysensor": "Der Entitätensensor erkennt die Anwesenheit von Entitäten (Spielern, Tieren, Wildtieren oder Monstern) im markierten Bereich und kann an den Ausgängen Informationen über deren Anzahl, Typ oder Zustand liefern. Der Sensor benötigt für den Betrieb eine Aufladung mit einem oder mehreren Zeiträdchen (Temporal gears). Die Verbrauchsgeschwindigkeit hängt dann von der Größe des überwachten Bereichs ab. <br> <strong>Eingänge x, y, z</strong> bestimmen die Größe des überwachten Bereichs in Blöcken. <br> Am Ausgang <strong>Fehler</strong> liegt Signal 1 an, wenn der Sensor entladen ist, sonst 0. <br> Die Eingänge <strong>Ausgang 1 einstellen</strong> und <strong>Ausgang 2 einstellen</strong> bestimmen, welche Informationen an den Ausgängen 1 und 2 bereitgestellt werden. An jedem Ausgang können Sie so je nach Einstellung dieser Eingänge eine andere Information erhalten. <br> Die Optionen sind: <br> 1 - Der Ausgang liefert <strong>Anzahl</strong>. Anzahl der erkannten Entitäten. <br> 2 - Der Ausgang liefert <strong>Kategorie</strong>. Bit-Flags der Entitätskategorie 0–3: Spieler, Kreatur, Tier, Wildtier. <br> 3 - Der Ausgang liefert <strong>Lebenszustand</strong>. Alle erkannten Entitäten sind: 1–tot, 2–lebendig oder 15–gemischt. <br> 4 - Der Ausgang liefert <strong>Geschlecht</strong>. Alle erkannten Entitäten sind: 1–männlich, 2–weiblich oder 15–gemischt. <br> 5 - Der Ausgang liefert <strong>Alter</strong>. Alle erkannten Entitäten sind: 1–Jungtier, 2–erwachsen oder 15–gemischt. <br> 6 - Der Ausgang liefert <strong>Art</strong>. Alle erkannten Entitäten sind: 1–Spieler, 2–Tier, 3–Wildtier, 4–Kreatur oder 15–gemischt. <br> 7 - Der Ausgang liefert <strong>Fortpflanzungszustand</strong>. Alle erkannten Entitäten sind: 1–paarungsbereit, 2–trächtig, 3–säugend oder 15–gemischt. <br> 8 - Der Ausgang liefert <strong>Flags des Fortpflanzungszustands</strong>. Bit-Flags 0–2: paarungsbereit, trächtig, säugend. <br> 9 - Der Ausgang liefert <strong>Minimale Generation</strong>. Die minimale erkannte Generation ist: 0–15. Vorhandene Entitäten ohne Generationsangabe werden ignoriert. <br> 10 - Der Ausgang liefert <strong>Maximale Generation</strong>. Die maximale erkannte Generation ist: 0–15. Vorhandene Entitäten ohne Generationsangabe werden ignoriert. <br> 11 - Der Ausgang liefert <strong>Minimales Gewicht</strong>. Das minimale erkannte Gewicht ist: 1–hungrig, 2–niedrig, 3–anständig, 4–gut. Vorhandene Entitäten ohne Gewichtsangabe (sind keine Tiere) werden ignoriert. <br> 12 - Der Ausgang liefert <strong>Maximales Gewicht</strong>. Das maximale erkannte Gewicht ist: 1–hungrig, 2–niedrig, 3–anständig, 4–gut. Vorhandene Entitäten ohne Gewichtsangabe (sind keine Tiere) werden ignoriert. <br> ",
  "signalslink:block-handbooktext-managedchute": "Die gesteuerte Röhre ermöglicht den automatisierten Transport von Gegenständen zwischen verschiedenen Blöcken. Sie transportiert Gegenstände nur in eine Richtung, die auf der Röhre mit einem weißen Pfeil markiert ist.<br> Im Gegensatz zur Rutsche hat die gesteuerte Röhre kein eigenes Inventar und transportiert Gegenstände vom Block auf der Quellseite direkt in den Block auf der Zielseite. Das bedeutet, dass die Gegenstände nicht in der Röhre gelagert werden, sondern nur durch sie hindurch befördert werden.<br> Die gesteuerte Röhre hat drei Signals-Anschlüsse: <strong>Eingang</strong>, <strong>Quelle</strong> und <strong>Ziel</strong>.<br> • <strong>Eingang</strong> dient zur Steuerung des Transports. Wenn am Eingang Signal 0 anliegt, ist die Röhre inaktiv und transportiert keine Gegenstände. Ein von Null verschiedener Wert am Eingang löst den Transport von Gegenständen von der Quelle zum Ziel aus. Unterstützt werden folgende Eingangswerte:<br> 1 - Transportiere einen Gegenstand<br> 2 - Transportiere 2 Gegenstände<br> 3 - Transportiere 4 Gegenstände<br> 4 - Transportiere 8 Gegenstände<br> 5 - Transportiere 16 Gegenstände<br> 6 - Transportiere 32 Gegenstände<br> 7 - Transportiere 64 Gegenstände<br> 15 - Transportiere dauerhaft.<br> Die Werte 1-7 am Eingang ermöglichen den Transport in Chargen. Wenn im Quellblock nicht genügend Gegenstände für die gewünschte Menge vorhanden sind, transportiert die Röhre so viel wie möglich und befördert den Rest erst, wenn am Eingang ein weiteres Signal erscheint. Wenn Sie eine andere Menge transportieren möchten, können Sie nacheinander verschiedene Signalwerte im Bereich 1 bis 7 an den Eingang senden und so die gewünschte Chargenmenge zusammensetzen.<br> Der Wert 15 am Eingang bewirkt, dass die Röhre Gegenstände von der Quelle zum Ziel dauerhaft transportiert, unabhängig davon, wie viele Gegenstände zu transportieren sind. Die Röhre setzt den Transport fort, sobald in der Quelle etwas erscheint, bis das Eingangssignal auf einen anderen Wert geändert wird.<br> Der Transport findet statt, wenn auf der Quellseite etwas zum Transportieren verfügbar ist und gleichzeitig auf der Zielseite Platz zum Einlagern der Gegenstände vorhanden ist. Wenn eine dieser Bedingungen nicht erfüllt ist, versucht die Röhre zu transportieren, bleibt jedoch, wenn es nicht möglich ist, inaktiv, bis sich die Situation ändert (z.B. Gegenstände in der Quelle erscheinen oder im Ziel Platz frei wird).<br> • <strong>Quelle</strong> ist relevant, falls der Eingangsblock ein Block mit Inventar ist. In diesem Fall bestimmt das Signal an der Quelle, aus welchem Slot die Gegenstände genommen werden sollen. Signal 1-14 bestimmt die Slots 0-13. Signal 15 bedeutet, dass Gegenstände aus dem letzten Slot genommen werden sollen.<br> Signal 0 bedeutet, dass Gegenstände aus einem beliebigen Slot genommen werden sollen. In diesem Fall durchsucht die Röhre alle Slots und nimmt Gegenstände aus dem ersten Slot, der nicht leer ist. Wenn der Quellblock kein Inventar hat, wird dieser Eingang ignoriert.<br> • <strong>Ziel</strong> ist relevant, falls der Ausgangsblock ein Block mit Inventar oder Luft ist. Bei einem Inventar bestimmt das Signal am Ziel, in welchen Slot die Gegenstände abgelegt werden sollen. Signal 1-15 bestimmt die Slots 0-14.<br> Wenn der Zielblock Luft ist und darunter Boden ist, sind folgende Zielwerte relevant: 1 - die Röhre versucht, einen Block aus der Quelle auf den Boden zu legen, 2 - die Röhre versucht, einen Gegenstand auf den Boden zu platzieren, sofern er platzierbar ist. Dies funktioniert vorerst nur mit Kohle und eignet sich z.B. zum automatischen Nachlegen unter einem Stahlofen.<br><br> Wenn der Quellblock Luft ist, sammelt die Röhre schwebende Gegenstände aus einem 3x3-Blockbereich, wobei der mittlere Block dieses Würfels der Block vor der Mündung der Röhre ist.<br><br> Die gesteuerte Röhre kann darüber hinaus auch Gegenstände vom Typ Ingot, Eisenschmelze und Blisterstahl in einen Amboss einlegen, wenn der Amboss auf der Zielseite der Röhre platziert ist. Beim Einlegen von Ingots wird automatisch das Schmiederezept für eine Platte gewählt. Bei Eisenschmelze und Blisterstahl wird das Ausschmieden der Schlacke gewählt, damit daraus Ingots entstehen. Das ist sehr nützlich für die Automatisierung des Schmiedens mit einem automatischen Hammer. Vor dem Einlegen in den Amboss müssen Sie jedoch dafür sorgen, dass die eingelegten Gegenstände auf die zum Schmieden benötigte Temperatur erhitzt sind. <br><br> <font size=\"20\" color=\"6082B6\">Transport filtern</font><br> Die gesteuerte Röhre ermöglicht das Festlegen von Bedingungen zum Filtern der Gegenstände, die transportiert werden sollen. Die Bedingungen werden mithilfe von <strong>Bedingungen auf Papier</strong> eingestellt, deren Verwendung <a href=\"handbook://signalslink:usageinfo-paperconditions\">auf dieser Seite</a> erklärt wird<br> ",
  "signalslink:block-handbooktext-managedwallchute": "Eine in die Wand eingesetzte gesteuerte Röhre ermöglicht den automatisierten Transport von Gegenständen zwischen verschiedenen Blöcken. Sie ermöglicht den Transport von Gegenständen durch Wände, was sehr nützlich für versteckte Transportsysteme oder für den Transport von Gegenständen aus dem Keller oder in den Keller sein kann, ohne dabei das kühle Kellerklima zu stören, das für die langfristige Lagerung von Lebensmitteln wichtig ist.<br> Sie funktioniert nach dem gleichen Prinzip wie die gesteuerte Röhre. Eine Beschreibung der Verwendung finden Sie daher auf der Seite mit der <a href=\"handbook://block-signalslink:managedchute-north-down\">Beschreibung der gesteuerten Röhre</a>.<br> ",
  "signalslink:usageinfo-signalslink-text": "<font size=\"25\"><strong>SignalsLink</strong></font> <br> Erweitert die Mod <a href=\"handbook://signals:craftinginfo-signals\">Signals</a> um weitere Komponenten. <br> <br> Zum Überwachen eines Blocks in der Umgebung können Sie den <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Blocksensor</a> verwenden. <br> Wenn Sie Ihre Rinderherde überwachen müssen, eignet sich dafür hervorragend der <a href=\"handbook://block-signalslink:entitysensor-off-north-down\">Entitätensensor</a>. <br> Wenn Sie einige Arbeiten automatisieren möchten, ist die <a href=\"handbook://block-signalslink:managedchute-north-down\">gesteuerte Röhre</a> eine ausgezeichnete Wahl; sie kann Gegenstände ähnlich wie eine Rutsche zwischen Blöcken transportieren, aber Sie steuern sie mit Signalen und erhalten viel mehr Kontrolle darüber, was transportiert wird. Ihre Variante <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">gesteuerte, in die Wand eingebaute Röhre</a> ermöglicht dann den Transport von Gegenständen durch Wände, was sehr nützlich für versteckte Transportsysteme oder für den Transport von Gegenständen aus dem Keller oder in den Keller sein kann, ohne dabei das kühle Kellerklima zu stören, das für die langfristige Lagerung von Lebensmitteln wichtig ist. ",
  "signalslink:usageinfo-paperconditions-text": "Einige Blöcke aus der Mod <a href=\"handbook://signalslink:usageinfo-signalslink\">SignalsLink</a> ermöglichen die Verwendung von <strong>Bedingungen auf Papier</strong>: <br> • <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Blocksensor</a> <br> • <a href=\"handbook://block-signalslink:managedchute-north-down\">gesteuerte Röhre</a> <br> • <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">gesteuerte, in die Wand eingebaute Röhre</a> <br> <font size=\"20\" color=\"6082B6\">Bedingungen auf Papier</font><br> <strong>Bedingungen auf Papier</strong> sind Bedingungen, die auf <a href=\"handbook://item-paper-parchment\">Pergament</a> geschrieben werden. Diese Bedingungen können verwendet werden, um das Verhalten eines Blocks zu beeinflussen, z.B. zur Steuerung von Ausgangssignalen oder zum Filtern von Gegenständen in Röhren. <br> Die Bedingungen werden in Blöcke (Absätze) geschrieben. Jeder Block besteht aus einer oder mehreren Zeilen, wobei in jeder Zeile eine Bedingung angegeben ist. Alle Bedingungen <strong>in einem Block</strong> werden so ausgewertet, dass zwischen ihnen der logische Operator AND angewendet wird und das Ergebnis den Gesamtwert des gesamten Blocks ergibt. <br> Einzelne Blöcke werden durch eine leere Zeile voneinander getrennt. Auf die resultierenden Werte der einzelnen Blöcke wird dann der logische Operator OR angewendet. Die Auswertung der einzelnen Bedingungen im Block erfolgt in der Reihenfolge von oben nach unten, so wie die Bedingungen auf dem Papier angegeben sind. Die Auswertung der Blöcke erfolgt ebenfalls in der Reihenfolge, in der die Blöcke auf dem Papier angegeben sind. Das bedeutet, sobald ein Block als wahr (true) ausgewertet wird, wird dieses Ergebnis an den aufrufenden Block zurückgegeben und mit dem nächsten Block nicht fortgefahren. Das ist sehr wichtig und muss berücksichtigt werden. <br> <br> Wir unterscheiden mehrere Arten von Bedingungen: <br> <strong>game:plank-oak</strong> - Es wird ausgewertet, ob der beobachtete Gegenstand im Inventar oder der beobachtete Block vom angegebenen Typ ist, d.h. sein Code entspricht genau dem angegebenen Code. Wenn ja, gibt die Bedingung true zurück.<br> <strong>game:plank-*</strong> - Es wird ausgewertet, ob der beobachtete Gegenstand oder Block vom angegebenen Typ in irgendeiner seiner Varianten (mit Sternchen gekennzeichnet) ist. Wenn ja, gibt die Bedingung true zurück.<br> <strong>@.*-plank-.*</strong> - Der Code des beobachteten Gegenstands oder Blocks wird mit diesem regulären Ausdruck ausgewertet. Bei Übereinstimmung gibt die Bedingung true zurück.<br> <strong>attribut &gt; 1</strong> - Es wird der Wert eines Attributs des Gegenstands im Inventar oder des beobachteten Blocks ausgewertet. Hier können verschiedene Vergleichsoperatoren (größer/kleiner/gleich) verwendet werden. Nach der Auswertung wird das Ergebnis des Vergleichs (true/false) zurückgegeben.<br> <strong>attribut</strong> - Wenn in der Bedingung nur der Name des Gegenstandsattributs angegeben wird, wird ausgewertet, ob es einen Wert hat oder nicht. D.h. null, NULL, leerer String oder false wird als false ausgewertet. Ein von Null verschiedener Wert, ein String oder true wird als true ausgewertet.<br> <br> Auf alle Bedingungen kann der Negationsoperator <strong>!</strong> angewendet werden. Zum Beispiel wird <strong>!game:plank-oak</strong> als true ausgewertet, wenn der beobachtete Gegenstand oder Block nicht genau Eichenbretter ist. <br> Am Ende jedes Blocks kann eine Anweisung zum Setzen des Ausgangssignals hinzugefügt werden, z.B. <strong>output 1</strong>, die angibt, dass, wenn dieser Block als wahr (true) ausgewertet wird, am Ausgang Signal 1 gesendet wird. Dies ist nur beim Block <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Blocksensor</a> relevant, der es ermöglicht festzulegen, welches Signal am Ausgang gesendet wird, wenn ein Block oder Gegenstand mit den im Block angegebenen Bedingungen übereinstimmt. Bei anderen Blöcken, die Bedingungen auf Papier unterstützen, wird diese Anweisung ignoriert. <font size=\"20\" color=\"6082B6\">Bedingungen einrichten</font><br> Sie schreiben die Bedingungen auf <a href=\"handbook://item-paper-parchment\">Pergament</a>. Unterschreiben Sie das Pergament nicht, damit Sie den Text später wieder bearbeiten können.<br> Sie übertragen die Bedingungen in einen Block, der dies unterstützt, indem Sie mit diesem Pergament mit der rechten Maustaste auf den entsprechenden Block klicken. Die Bedingungen werden so im Block gespeichert und Sie sehen sie im Informationsfenster, wenn Sie den Block ansehen. <br> Um Bedingungen aus einem Block zu entfernen, nehmen Sie ein leeres Pergament in die Hand, ducken Sie sich (Shift-Taste) und klicken Sie mit diesem leeren Pergament auf den entsprechenden Block. Damit haben Sie die Bedingungen aus dem Block gelöscht.<br> Wenn Sie Bedingungen aus einem Block auf ein leeres Pergament kopieren möchten, klicken Sie ohne Ducken mit der rechten Maustaste mit einem leeren Pergament auf den entsprechenden Block.<br> Und schließlich eine Hilfe, um herauszufinden, welchen Code ein Block oder Gegenstand hat und welche Attribute Ihnen für die Verwendung in Bedingungsausdrücken zur Verfügung stehen:<br> Nehmen Sie den Gegenstand, der Sie interessiert, in die Hand, halten Sie die Ctrl-Taste gedrückt und klicken Sie mit der rechten Maustaste mit diesem Block auf einen Block, der Bedingungen auf Papier unterstützt. Der Code des Gegenstands und seine für Bedingungen auf Papier verfügbaren Attribute werden in diesem Block gespeichert. Sie können sie nun auf ein leeres Pergament kopieren, wie oben beschrieben, und dort beliebig in Bedingungsblöcke umarbeiten und zur Blockkonfiguration verwenden. ",
  "signalslink:usageinfo-paperconditions-title": "SignalsLink - Bedingungen auf Papier"
}
