{
  "game:tabname-signalslink": "Signals Link",
  "signalslink:block-blocksensor-*": "Датчик блоков",
  "signals:con-input": "Вход",
  "signals:con-output": "Выход",
  "signals:con-target": "Цель",
  "signals:con-source": "Источник",
  "signalslink:block-entitysensor-*": "Датчик сущностей",
  "signals:con-x": "X",
  "signals:con-y": "Y",
  "signals:con-z": "Z",
  "signals:con-error-state": "Состояние ошибки",
  "signals:con-output1": "Выход 1",
  "signals:con-output2": "Выход 2",
  "signals:con-output1-config": "Настройка выхода 1",
  "signals:test": "Мы тестируем переводы на уроке ИИ.",
  "signals:con-output2-config": "Настройка выхода 2",
  "signalslink:entitysensor-charged": "Заряжено. Добавлено {0} единиц. Максимальный предел заряда — {1} единиц.",
  "signalslink:entitysensor-already-fully-charged": "Это устройство уже полностью заряжено.",
  "signalslink:blockinfo-charge": "Заряд: {0}/{1} единиц ({2}%)",
  "signalslink:blockinfo-charge-at-volume": "При текущем покрытии ({0} блоков) проработает: ~{1} дней",
  "signalslink:blockinfo-charge-empty": "Заряд: Пусто — нужен temporal gear",
  "signalslink:usageinfo-signalslink-title": "SignalsLink — расширение мода Signals",
  "signalslink:block-managedchute-*": "Управляемая труба",
  "signalslink:block-managedwallchute-wood-*": "Управляемая труба, встроенная в дерево",
  "signalslink:block-managedwallchute-rock-*": "Управляемая труба, встроенная в камень",
  "signalslink:block-managedwallchute-cobble-*": "Управляемая труба, встроенная в плитку",
  "signalslink:managedchute-conditions": "Условия",
  "signalslink:managedchute-info-unlimited": "Транспортирует постоянно",
  "signalslink:managedchute-info-remaining": "Транспортирует {0}",
  "signalslink:block-handbooktitle-signalslink": "Функции сигналов",
  "signalslink:block-handbooktext-blocksensor": "    Датчик блоков обнаруживает наличие блока в выбранной соседней позиции и, в зависимости от его типа и, при необходимости, входного сигнала, выдает на выходе информацию о его состоянии или заполнении слотов.    <br>    <font size=\"20\" color=\"6082B6\">На данный момент поддерживаются следующие блоки:<\\/font>    <br>    <strong>Наковальня<\\/strong> - если на наковальне находится достаточно раскаленный слиток для ковки, на выходе сигнал 1. В противном случае подается сигнал 0.    <br>    <strong>Двери, ворота, люки<\\/strong> - у дверей и ворот необходимо отслеживать блок у земли со стороны петель. Если блок открыт, на выходе сигнал 1, если закрыт — на выходе сигнал 0.    <br>    <strong>Сундук или вообще контейнер, или любые блоки, у которых есть какие-либо слоты инвентаря<\\/strong> (например, кострище, бочка, корыто и т. п.). На выходе сигнал в зависимости от входного сигнала.    <br>    Входной сигнал определяет, какой слот должен быть просканирован.    <br>    Сигнал 1–14 определяет слоты 0–13. Выходом является информация о заполнении слота относительно максимальной вместимости стака предмета в данном слоте, преобразованная в сигнал 0–15.    <br>    Сигнал 15 определяет, что датчик должен обнаруживать общее заполнение всех слотов, например всего сундука.    <br>    <strong>Какой-либо другой блок, не указанный выше<\\/strong> - если в отслеживаемом пространстве ничего нет (там воздух), на выходе сигнал 0. Если там вода, на выходе 2 — пресная или 3 — соленая вода. Если там какой-либо другой блок, на выходе сигнал 1.    <br>",
  "signalslink:block-handbooktext-entitysensor": "    Датчик существ обнаруживает присутствие сущностей (игроков, домашних животных, диких животных или монстров) в заданной области и может на выходах предоставлять информацию об их количестве, типе или состоянии. Для своей работы датчик требует зарядки одним или несколькими временными шестеренками (Temporal gears). Скорость расхода зависит от размера отслеживаемой области.    <br>    <strong>Входы x, y, z<\\/strong> определяют размер отслеживаемой области в блоках.    <br>    На выходе <strong>Ошибка<\\/strong> сигнал 1, если датчик разряжен, иначе 0.    <br>    Входы <strong>Настройка выхода 1<\\/strong> и <strong>Настройка выхода 2<\\/strong> определяют, какая информация будет предоставляться на выходах 1 и 2. На каждом выходе вы можете получать различную информацию в зависимости от настройки этих входов.    <br>    Возможные варианты:    <br>    1 - Выход возвращает <strong>Количество<\\/strong>. Количество обнаруженных сущностей.    <br>    2 - Выход возвращает <strong>Категорию<\\/strong>. Битовые флаги категории сущностей 0–3: игрок, создание, домашнее животное, дикое животное.    <br>    3 - Выход возвращает <strong>Состояние жизни<\\/strong>. Все обнаруженные сущности: 1–мертвые, 2–живые или 15–смешанные.    <br>    4 - Выход возвращает <strong>Пол<\\/strong>. Все обнаруженные сущности: 1–самец, 2–самка или 15–смешанные.    <br>    5 - Выход возвращает <strong>Возраст<\\/strong>. Все обнаруженные сущности: 1–детеныш, 2–взрослый или 15–смешанные.    <br>    6 - Выход возвращает <strong>Вид<\\/strong>. Все обнаруженные сущности: 1–игрок, 2–домашнее животное, 3–дикое животное, 4–создание или 15–смешанные.    <br>    7 - Выход возвращает <strong>Репродуктивное состояние<\\/strong>. Все обнаруженные сущности: 1–готовы к спариванию, 2–беременные, 3–кормящие или 15–смешанные.    <br>    8 - Выход возвращает <strong>Флаги репродуктивного состояния<\\/strong>. Битовые флаги 0–2: готовы к спариванию, беременные, кормящие.    <br>    9 - Выход возвращает <strong>Минимальное поколение<\\/strong>. Минимальное обнаруженное поколение: 0–15. Присутствующие сущности без указанного поколения игнорируются.    <br>    10 - Выход возвращает <strong>Максимальное поколение<\\/strong>. Максимальное обнаруженное поколение: 0–15. Присутствующие сущности без указанного поколения игнорируются.    <br>    11 - Выход возвращает <strong>Минимальный вес<\\/strong>. Минимальный обнаруженный вес: 1–голодающий, 2–низкий, 3–нормальный, 4–хороший. Присутствующие сущности без указанного веса (не животные) игнорируются.    <br>    12 - Выход возвращает <strong>Максимальный вес<\\/strong>. Максимальный обнаруженный вес: 1–голодающий, 2–низкий, 3–нормальный, 4–хороший. Присутствующие сущности без указанного веса (не животные) игнорируются.    <br>",
  "signalslink:block-handbooktext-managedchute": "    Управляемая труба позволяет автоматизированную транспортировку предметов между различными блоками.",
  "signalslink:block-handbooktext-managedwallchute": "    Управляемая труба, встроенная в стену, позволяет автоматизированную транспортировку предметов между различными блоками. Позволяет транспортировать предметы сквозь стены, что может быть очень полезно для скрытых транспортных систем или для транспортировки предметов из подвала или в подвал, не нарушая при этом прохладную среду погреба, важную для долгосрочного хранения продуктов.",
  "signalslink:usageinfo-signalslink-text": "    <font size=\"25\"><strong>SignalsLink<\\/strong><\\/font>    <br>    Расширяет мод <a href=\"handbook://signals:craftinginfo-signals\">Signals<\\/a> дополнительными компонентами.    <br>    <br>    Для отслеживания какого-либо блока поблизости вы можете использовать <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">датчик блоков<\\/a>.    <br>    Если вам нужно следить за вашим стадом скота, для этого отлично подойдет <a href=\"handbook://block-signalslink:entitysensor-off-north-down\">датчик существ<\\/a>.    <br>    Если вы хотите автоматизировать некоторые работы, вам прекрасно послужит <a href=\"handbook://block-signalslink:managedchute-north-down\">управляемая труба<\\/a>, которая умеет транспортировать предметы между блоками подобно лотку, но вы управляете ею сигналами и получаете гораздо больший контроль над тем, что транспортируется. Ее вариант <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">управляемая труба, встроенная в стену<\\/a>, позволяет транспортировать предметы сквозь стены, что может быть очень полезно для скрытых транспортных систем или для транспортировки предметов из подвала или в подвал, не нарушая при этом прохладную среду погреба, важную для долгосрочного хранения продуктов.",
  "signalslink:usageinfo-paperconditions-text": "    Некоторые блоки из мода <a href=\"handbook://signalslink:usageinfo-signalslink\">SignalsLink<\\/a> позволяют использовать <strong>условия на бумаге<\\/strong>:    <br>    • <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">датчик блоков<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedchute-north-down\">управляемая труба<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">управляемая труба, встроенная в стену<\\/a>    <br>    <font size=\"20\" color=\"6082B6\">Условия на бумаге<\\/font>    <strong>условия на бумаге<\\/strong> — это условия, записанные на <a href=\"handbook://item-paper-parchment\">пергаменте<\\/a>. Эти условия могут использоваться для влияния на поведение блока, например для управления выходными сигналами или для фильтрации предметов в трубах.    <br>    Условия записываются в блоки (абзацы). Каждый блок состоит из одной или нескольких строк, при этом в каждой строке указано одно условие. Все условия <strong>в одном блоке<\\/strong> оцениваются так, что между ними применяется логический оператор AND, и результат дает итоговое значение всего блока.    <br>    Отдельные блоки разделяются пустой строкой. К итоговым значениям отдельных блоков затем применяется логический оператор OR. Оценка отдельных условий в блоке выполняется в порядке сверху вниз, в каком условия указаны на бумаге. Оценка блоков также выполняется в порядке, в котором блоки указаны на бумаге. Это означает, что как только какой-либо блок оценивается как истина (true), этот результат возвращается вызывающему блоку, и к следующему блоку уже не переходят. Это очень важно, и с этим нужно считаться.    <br>    <br>    Мы различаем несколько типов условий:    <br>    <strong>game:plank-oak<\\/strong> - оценивается, является ли отслеживаемый предмет в инвентаре или отслеживаемый блок заданного типа, то есть его код точно соответствует указанному коду. Если да, условие возвращает true.<br>    <strong>game:plank-*<\\/strong> - оценивается, является ли отслеживаемый предмет или блок заданного типа в любой его разновидности (обозначенной звездочкой). Если да, условие возвращает true.<br>    <strong>@.*-plank-.*<\\/strong> - код отслеживаемого предмета или блока оценивается данным регулярным выражением. Если есть совпадение, условие возвращает true.<br>    <strong>attribut > 1<\\/strong> - оценивается значение атрибута предмета в инвентаре или отслеживаемого блока. Здесь можно использовать различные операторы сравнения (больше/меньше/равно). После оценки возвращается результат сравнения (true/false).<br>    <strong>attribut<\\/strong> - если в условии указан только атрибут предмета, оценивается, есть у него значение или нет. То есть ноль, NULL, пустая строка или false оцениваются как false. Ненулевое значение, строка или true оцениваются как true.<br>    <br>    Ко всем условиям можно применить оператор отрицания <strong>!<\\/strong>. Например, !game:plank-oak оценивается как true, если отслеживаемый предмет или блок не является именно дубовыми досками.    <br>    В конец каждого блока можно добавить инструкцию для установки выходного сигнала, например <strong>output 1<\\/strong>, которая определяет, что если этот блок оценивается как истина (true), на выход будет отправлен сигнал 1. Это имеет смысл только для блока <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">датчик блоков<\\/a>, который позволяет задать, какой сигнал будет отправлен на выход в случае, если какой-либо блок или предмет соответствует условиям, указанным в блоке. Для остальных блоков, которые позволяют использовать условия на бумаге, эта инструкция игнорируется.    <font size=\"20\" color=\"6082B6\">Настройка условий<\\/font>    Условия вы записываете на <a href=\"handbook://item-paper-parchment\">пергамент<\\/a>. Пергамент не подписывайте, чтобы вы могли редактировать текст повторно.<br>    Условия вы переносите в блок, который это поддерживает, щелкнув этим пергаментом правой кнопкой мыши по данному блоку. Условия таким образом сохраняются в блок и вы увидите их в информационном окне, когда посмотрите на блок. <br>    Для удаления условий из блока возьмите в руку пустой пергамент, присядьте (клавиша Shift) и щелкните этим пустым пергаментом по данному блоку. Тем самым вы удалите условия из блока.<br>    Если вы хотите скопировать условия из блока на пустой пергамент, щелкните пустым пергаментом правой кнопкой мыши по данному блоку без приседания.<br>    И напоследок подсказка для определения того, какой код имеет какой-либо блок или предмет и какие атрибуты у вас есть в распоряжении для использования в условных выражениях:<br>    Возьмите в руку предмет, который вас интересует, удерживайте клавишу Ctrl и щелкните правой кнопкой мыши этим предметом по блоку, который поддерживает условия на бумаге. Код предмета и его атрибуты, доступные для условий на бумаге, сохранятся в этот блок. Теперь вы можете скопировать их на пустой пергамент, как было описано выше, и там произвольно отредактировать на блоки условий и использовать их для настройки блока.",
  "signalslink:usageinfo-paperconditions-title": "Условия на бумаге"
}
