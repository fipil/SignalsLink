{
  "game:tabname-signalslink": "Signals Link",
  "signalslink:block-blocksensor-*": "Блочный сенсор",
  "signals:con-input": "Вход",
  "signals:con-output": "Выход",
  "signals:con-target": "Цель",
  "signals:con-source": "Источник",
  "signalslink:block-entitysensor-*": "Сенсор существ",
  "signals:con-x": "X",
  "signals:con-y": "Y",
  "signals:con-z": "Z",
  "signals:con-error-state": "Состояние ошибки",
  "signals:con-output1": "Выход 1",
  "signals:con-output2": "Выход 2",
  "signals:con-output1-config": "Настройки выхода 1",
  "signals:test": "Тестируем переводы в AI-часике.",
  "signals:con-output2-config": "Настройки выхода 2",
  "signalslink:entitysensor-charged": "Заряжено. Добавлено {0} единиц. Максимальный предел заряда — {1} единиц.",
  "signalslink:entitysensor-already-fully-charged": "Этот прибор уже полностью заряжен.",
  "signalslink:blockinfo-charge": "Заряд: {0}/{1} единиц ({2}%)",
  "signalslink:blockinfo-charge-at-volume": "При текущем покрытии ({0} блоков) сможет работать: ~{1} дней",
  "signalslink:blockinfo-charge-empty": "Заряд: Пусто — нужен temporal gear",
  "signalslink:usageinfo-signalslink-title": "SignalsLink — расширение мода Signals",
  "signalslink:block-managedchute-*": "Управляемая труба",
  "signalslink:block-managedwallchute-wood-*": "Управляемая труба, встроенная в дерево",
  "signalslink:block-managedwallchute-rock-*": "Управляемая труба, встроенная в скалу",
  "signalslink:block-managedwallchute-cobble-*": "Управляемая труба, встроенная в плитку",
  "signalslink:managedchute-conditions": "Условия",
  "signalslink:managedchute-info-unlimited": "Транспортирует постоянно",
  "signalslink:managedchute-info-remaining": "Транспортирует {0}",
  "signalslink:block-handbooktitle-signalslink": "Сигнальные функции",
  "signalslink:block-handbooktext-blocksensor": "    Датчик блоков обнаруживает наличие блока на выбранной соседней позиции и, в зависимости от его типа либо входного сигнала, выдаёт на выходе информацию о его состоянии или заполненности слотов.    <br>    <font size=\"20\" color=\"6082B6\">На данный момент поддерживаются следующие блоки:<\\/font>    <br>    <strong>Наковальня<\\/strong> — если на наковальне есть достаточно раскалённый слиток для ковки, на Выходе сигнал 1. Иначе отправляет сигнал 0.    <br>    <strong>Двери, ворота, люки<\\/strong> — для дверей и ворот нужно отслеживать блок у земли со стороны петель. Если блок открыт, на Выходе сигнал 1, если закрыт — на Выходе сигнал 0.    <br>    <strong>Сундук или вообще контейнер или любые блоки, у которых есть какие-либо слоты инвентаря<\\/strong> (например, очаг, бочка, кормушка и т. п.). На Выходе сигнал согласно входному сигналу.    <br>    Входной сигнал определяет, какой слот должен быть просканирован.    <br>    Сигнал 1–14 определяет слоты 0–13. Выходом является информация о заполненности слота относительно максимальной ёмкости стака предмета в данном слоте, преобразованная в сигнал 0–15.    <br>    Сигнал 15 означает, что датчик должен определять общую заполненность всех слотов, например, всего сундука.    <br>    <strong>Какой-то другой блок, не указанный выше<\\/strong> — если в отслеживаемом пространстве ничего нет (там воздух), на Выходе сигнал 0. Если там вода, на выходе 2 — пресная или 3 — солёная вода. Если там любой другой блок, на Выходе сигнал 1.    <br>",
  "signalslink:block-handbooktext-entitysensor": "    Датчик существ обнаруживает наличие сущностей (игроков, животных, диких животных или монстров) в отмеченной области и умеет на выходах предоставлять информацию об их количестве, типе или состоянии. Для работы датчику требуется зарядка    одним или несколькими временными шестернями (Temporal gears). Скорость расхода зависит от размера отслеживаемой области.    <br>    <strong>Входы x, y, z<\\/strong> определяют размер отслеживаемой области в блоках.    <br>    На выходе <strong>Ошибка<\\/strong> сигнал 1, если датчик разряжен, иначе 0.    <br>    Входы <strong>Настройка выхода 1<\\/strong> и <strong>Настройка выхода 2<\\/strong> определяют, какая информация будет предоставляться на выходах 1 и 2. На каждом выходе вы можете получать разную информацию, в зависимости от настройки этих входов.    <br>    Варианты:    <br>    1 — Выход возвращает <strong>Количество<\\/strong>. Количество обнаруженных сущностей.    <br>    2 — Выход возвращает <strong>Категорию<\\/strong>. Битовые флаги категории сущностей 0–3: игрок, существо, животное, дикое животное.    <br>    3 — Выход возвращает <strong>Состояние жизни<\\/strong>. Все обнаруженные сущности: 1 — мёртвые, 2 — живые или 15 — смешанные.    <br>    4 — Выход возвращает <strong>Пол<\\/strong>. Все обнаруженные сущности: 1 — самец, 2 — самка или 15 — смешанные.    <br>    5 — Выход возвращает <strong>Возраст<\\/strong>. Все обнаруженные сущности: 1 — детёныш, 2 — взрослый или 15 — смешанные.    <br>    6 — Выход возвращает <strong>Вид<\\/strong>. Все обнаруженные сущности: 1 — игрок, 2 — животное, 3 — дикое животное, 4 — существо или 15 — смешанные.    <br>    7 — Выход возвращает <strong>Репродуктивное состояние<\\/strong>. Все обнаруженные сущности: 1 — готовы к спариванию, 2 — беременные, 3 — кормящие или 15 — смешанные.    <br>    8 — Выход возвращает <strong>Флаги репродуктивного состояния<\\/strong>. Битовые флаги 0–2: готовы к спариванию, беременные, кормящие.    <br>    9 — Выход возвращает <strong>Минимальное поколение<\\/strong>. Минимально обнаруженное поколение: 0–15. Присутствующие сущности без определения поколения игнорируются.    <br>    10 — Выход возвращает <strong>Максимальное поколение<\\/strong>. Максимально обнаруженное поколение: 0–15. Присутствующие сущности без определения поколения игнорируются.    <br>    11 — Выход возвращает <strong>Минимальную упитанность<\\/strong>. Минимально обнаруженная упитанность: 1 — голодающий, 2 — низкая, 3 — приличная, 4 — хорошая. Присутствующие сущности без определения упитанности (не животные) игнорируются.    <br>    12 — Выход возвращает <strong>Максимальную упитанность<\\/strong>. Максимально обнаруженная упитанность: 1 — голодающий, 2 — низкая, 3 — приличная, 4 — хорошая. Присутствующие сущности без определения упитанности (не животные) игнорируются.    <br>",
  "signalslink:block-handbooktext-managedchute": "    Управляемая труба позволяет автоматизировать транспортировку предметов между различными блоками.",
  "signalslink:block-handbooktext-managedwallchute": "    Управляемая труба, встроенная в стену, позволяет автоматизировать транспортировку предметов между различными блоками. Она позволяет переносить предметы сквозь стены, что может быть очень полезно для скрытых транспортных систем    или для переноса предметов из погреба или в погреб, не нарушая прохладную погребную среду, важную для долгосрочного хранения пищи.",
  "signalslink:usageinfo-signalslink-text": "    <font size=\"25\"><strong>SignalsLink<\\/strong><\\/font>    <br>    Расширяет мод <a href=\"handbook://signals:craftinginfo-signals\">Signals<\\/a> дополнительными компонентами.    <br>    <br>    Для отслеживания какого-либо блока поблизости можно использовать <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Датчик блоков<\\/a>.    <br>    Если вам нужно следить за вашим стадом скота, для этого отлично подойдёт <a href=\"handbook://block-signalslink:entitysensor-off-north-down\">Датчик существ<\\/a>.    <br>    Если вы хотите автоматизировать некоторые работы, вам отлично послужит <a href=\"handbook://block-signalslink:managedchute-north-down\">Управляемая труба<\\/a>, которая умеет переносить предметы между блоками подобно желобу, но вы управляете ей сигналами, и она даёт вам    гораздо больший контроль над тем, что переносится. Её вариант <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">Управляемая труба, встроенная в стену<\\/a> затем позволяет переносить предметы сквозь стены, что может быть очень полезно для скрытых транспортных систем    или для переноса предметов из погреба или в погреб, не нарушая прохладную погребную среду, важную для долгосрочного хранения пищи.",
  "signalslink:usageinfo-paperconditions-text": "    Некоторые блоки из мода <a href=\"handbook://signalslink:usageinfo-signalslink\">SignalsLink<\\/a> позволяют использовать <strong>условия на бумаге<\\/strong>:    <br>    • <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Датчик блоков<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedchute-north-down\">Управляемая труба<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">Управляемая труба, встроенная в стену<\\/a>    <br>    <font size=\"20\" color=\"6082B6\">Условия на бумаге<\\/font>    <strong>условия на бумаге<\\/strong> — это условия, написанные на <a href=\"handbook://item-paper-parchment\">пергаменте<\\/a>. Эти условия могут использоваться для влияния на поведение блока, например для управления выходными сигналами или для фильтрации предметов в трубах.    <br>    Условия пишутся в блоки (абзацы). Каждый блок состоит из одной или нескольких строк, при этом в каждой строке указано одно условие. Все условия <strong>в одном блоке<\\/strong> вычисляются так, что между ними применяется логический оператор AND,    а результат даёт итоговое значение всего блока.    <br>    Отдельные блоки отделяются друг от друга пустой строкой. К итоговым значениям отдельных блоков затем применяется логический оператор OR. Вычисление отдельных условий в блоке происходит в порядке сверху вниз, как условия указаны на бумаге.    Вычисление блоков также происходит в том порядке, в котором блоки указаны на бумаге. Это означает, что как только какой-либо блок вычислится как истина (true), этот результат возвращается в вызывающий блок, и последующие блоки уже не обрабатываются.    Это очень важно, и это нужно учитывать.    <br>    <br>    Различаем несколько типов условий:    <br>    <strong>game:plank-oak<\\/strong> — проверяется, является ли отслеживаемый предмет в инвентаре или отслеживаемый блок заданного типа, то есть его код точно соответствует указанному коду. Если да, условие вернёт true.<br>    <strong>game:plank-*<\\/strong> — проверяется, является ли отслеживаемый предмет или блок заданного типа в любой его вариации (обозначенной звёздочкой). Если да, условие вернёт true.<br>    <strong>@.*-plank-.*<\\/strong> — код отслеживаемого предмета или блока проверяется этим регулярным выражением. При совпадении условие вернёт true.<br>    <strong>attribut > 1<\\/strong> — проверяется значение атрибута предмета в инвентаре или отслеживаемого блока. Здесь можно использовать различные операторы сравнения (больше/меньше/равно). После вычисления возвращается результат сравнения (true/false).<br>    <strong>attribut<\\/strong> — если в условии указано только имя атрибута предмета, проверяется, есть ли у него значение. То есть ноль, NULL, пустая строка или false оцениваются как false. Ненулевое значение, строка или true оцениваются как true.<br>    <br>    Ко всем условиям можно применить оператор отрицания <strong>!<\\/strong>. Например, !game:plank-oak вычисляется как true, если отслеживаемый предмет или блок не является точно дубовыми досками.    <br>    В конец каждого блока можно добавить инструкцию для установки выходного сигнала, например <strong>output 1<\\/strong>, которая означает, что если этот блок вычислится как истина (true), на выход будет отправлен сигнал 1.    Это имеет смысл только для блока <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Датчик блоков<\\/a>, который позволяет настроить, какой сигнал будет отправлен на выход в случае, если какой-либо блок или предмет соответствует условиям, указанным в блоке. Для остальных блоков, которые позволяют использовать условия на бумаге, эта инструкция игнорируется.    <font size=\"20\" color=\"6082B6\">Настройка условий<\\/font>    Условия вы напишете на <a href=\"handbook://item-paper-parchment\">пергаменте<\\/a>. Пергамент не подписывайте, чтобы вы могли снова редактировать текст.<br>    Условия перенесёте в блок, который это поддерживает, так, что щёлкнете этим пергаментом правой кнопкой мыши по соответствующему блоку. Условия таким образом сохранятся в блоке, и вы увидите их в информационном окне, когда посмотрите на блок. <br>    Чтобы удалить условия из блока, возьмите в руку пустой пергамент, присядьте (клавиша shift) и щёлкните этим пустым пергаментом по соответствующему блоку. Так вы удалите условия из блока.<br>    Если вы хотите скопировать условия из блока на пустой пергамент, щёлкните пустым пергаментом правой кнопкой мыши по соответствующему блоку без приседания.<br>    И наконец, подсказка, как узнать, какой у какого-либо блока или предмета код и какие атрибуты у вас доступны для использования в условных выражениях:<br>    Возьмите в руку предмет, который вас интересует, удерживайте клавишу ctrl и щёлкните правой кнопкой мыши этим блоком по блоку, который поддерживает условия на бумаге. Код предмета и его атрибуты, доступные для условий на бумаге, сохранятся в этом блоке. Теперь вы можете скопировать их на     пустой пергамент, как было описано выше, и здесь произвольно отредактировать на блоки условий и использовать их для настройки блока.",
  "signalslink:usageinfo-paperconditions-title": "Условия на бумаге"
}
