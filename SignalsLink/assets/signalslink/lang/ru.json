{
  "game:tabname-signalslink": "Signals Link",
  "signalslink:block-blocksensor-*": "Датчик блоков",
  "signals:con-input": "Вход",
  "signals:con-output": "Выход",
  "signals:con-target": "Цель",
  "signals:con-source": "Источник",
  "signalslink:block-entitysensor-*": "Датчик сущностей",
  "signals:con-x": "X",
  "signals:con-y": "Y",
  "signals:con-z": "Z",
  "signals:con-error-state": "Состояние ошибки",
  "signals:con-output1": "Выход 1",
  "signals:con-output2": "Выход 2",
  "signals:con-output1-config": "Настройка выхода 1",
  "signals:test": "Мы тестируем переводы на уроке ИИ.",
  "signals:con-output2-config": "Настройка выхода 2",
  "signalslink:entitysensor-charged": "Заряжено. Добавлено {0} единиц. Максимальный предел заряда — {1} единиц.",
  "signalslink:entitysensor-already-fully-charged": "Это устройство уже полностью заряжено.",
  "signalslink:blockinfo-charge": "Заряд: {0}/{1} единиц ({2}%)",
  "signalslink:blockinfo-charge-at-volume": "При текущем покрытии ({0} блоков) проработает: ~{1} дней",
  "signalslink:blockinfo-charge-empty": "Заряд: Пусто — нужен temporal gear",
  "signalslink:usageinfo-signalslink-title": "SignalsLink — расширение мода Signals",
  "signalslink:block-managedchute-*": "Управляемая труба",
  "signalslink:block-managedwallchute-wood-*": "Управляемая труба, встроенная в дерево",
  "signalslink:block-managedwallchute-rock-*": "Управляемая труба, встроенная в камень",
  "signalslink:block-managedwallchute-cobble-*": "Управляемая труба, встроенная в плитку",
  "signalslink:managedchute-conditions": "Условия",
  "signalslink:managedchute-info-unlimited": "Транспортирует постоянно",
  "signalslink:managedchute-info-remaining": "Транспортирует {0}",
  "signalslink:block-handbooktitle-signalslink": "Функции сигналов",
  "signalslink:block-handbooktext-blocksensor": "    Датчик блоков обнаруживает наличие блока в выбранной соседней позиции и, в зависимости от его типа и, при необходимости, входного сигнала, предоставляет на выходе информацию о его состоянии или заполнении слотов.    <br>    <font size=\"20\" color=\"6082B6\">На данный момент поддерживаются блоки:<\\/font>    <br>    <strong>Наковальня<\\/strong> - если на наковальне находится достаточно раскалённый слиток для ковки, на выходе сигнал 1. В противном случае подаётся сигнал 0.    <br>    <strong>Двери, калитки, люки<\\/strong> - у дверей и калиток нужно отслеживать блок у земли со стороны петель. Если блок открыт, на выходе сигнал 1, если закрыт – на выходе сигнал 0.    <br>    <strong>Сундук или в общем контейнер либо любые блоки, у которых есть какие-либо инвентарные слоты<\\/strong> (например, кострище, бочка, корыто и т. п.). На выходе сигнал в соответствии со входным сигналом.    <br>    Входной сигнал определяет, какой слот должен быть просканирован.    <br>    Сигнал 1–14 определяет слоты 0–13. Выходом является информация о заполнении слота относительно максимальной вместимости стака предмета в данном слоте, преобразованная в сигнал 0–15.    <br>    Сигнал 15 определяет, что датчик должен обнаруживать общее заполнение всех слотов, например всего сундука.    <br>    <strong>Какой-либо другой блок, не указанный выше<\\/strong> - если в отслеживаемом пространстве ничего нет (там воздух), на выходе сигнал 0. Если там вода, на выходе 2 – пресная или 3 – солёная вода. Если там какой-либо другой блок, на выходе сигнал 1.    <br>",
  "signalslink:block-handbooktext-entitysensor": "    Датчик существ обнаруживает наличие сущностей (игроков, домашних животных, диких животных или монстров) в указанной области и может на выходах предоставлять информацию об их количестве, типе или состоянии. Для работы датчику требуется зарядка одним или несколькими временными шестерёнками (Temporal gears). Скорость расхода зависит от размера отслеживаемой области.    <br>    <strong>Входы x, y, z<\\/strong> определяют размер отслеживаемой области в блоках.    <br>    На выходе <strong>Ошибка<\\/strong> подаётся сигнал 1, если датчик разряжен, иначе 0.    <br>    Входы <strong>Настройка выхода 1<\\/strong> и <strong>Настройка выхода 2<\\/strong> определяют, какая информация будет предоставляться на выходах 1 и 2. На каждом выходе вы можете получать разную информацию, в зависимости от настроек этих входов.    <br>    Варианты:    <br>    1 - Выход возвращает <strong>Количество<\\/strong>. Количество обнаруженных сущностей.    <br>    2 - Выход возвращает <strong>Категорию<\\/strong>. Битовые признаки категории сущностей 0–3: игрок, создание, домашнее животное, дикое животное.    <br>    3 - Выход возвращает <strong>Состояние жизни<\\/strong>. Все обнаруженные сущности: 1 – мёртвые, 2 – живые или 15 – смешанные.    <br>    4 - Выход возвращает <strong>Пол<\\/strong>. Все обнаруженные сущности: 1 – самец, 2 – самка или 15 – смешанные.    <br>    5 - Выход возвращает <strong>Возраст<\\/strong>. Все обнаруженные сущности: 1 – детёныш, 2 – взрослый или 15 – смешанные.    <br>    6 - Выход возвращает <strong>Вид<\\/strong>. Все обнаруженные сущности: 1 – игрок, 2 – домашнее животное, 3 – дикое животное, 4 – создание или 15 – смешанные.    <br>    7 - Выход возвращает <strong>Репродуктивное состояние<\\/strong>. Все обнаруженные сущности: 1 – готовые к спариванию, 2 – беременные, 3 – кормящие или 15 – смешанные.    <br>    8 - Выход возвращает <strong>Признаки репродуктивного состояния<\\/strong>. Битовые признаки 0–2: готовые к спариванию, беременные, кормящие.    <br>    9 - Выход возвращает <strong>Минимальное поколение<\\/strong>. Минимально обнаруженное поколение: 0–15. Присутствующие сущности без указания поколения игнорируются.    <br>    10 - Выход возвращает <strong>Максимальное поколение<\\/strong>. Максимально обнаруженное поколение: 0–15. Присутствующие сущности без указания поколения игнорируются.    <br>    11 - Выход возвращает <strong>Минимальный вес<\\/strong>. Минимально обнаруженный вес: 1 – истощённый, 2 – низкий, 3 – неплохой, 4 – хороший. Присутствующие сущности без указания веса (если это не животные) игнорируются.    <br>    12 - Выход возвращает <strong>Максимальный вес<\\/strong>. Максимально обнаруженный вес: 1 – истощённый, 2 – низкий, 3 – неплохой, 4 – хороший. Присутствующие сущности без указания веса (если это не животные) игнорируются.    <br>",
  "signalslink:block-handbooktext-managedchute": "    Управляемый желоб позволяет автоматически перемещать предметы между различными блоками.",
  "signalslink:block-handbooktext-managedwallchute": "    Управляемый желоб, встроенный в стену, позволяет автоматически перемещать предметы между различными блоками. Позволяет перемещать предметы сквозь стены, что может быть очень полезно для скрытых транспортных систем или для перемещения предметов из подвала или в подвал, не нарушая прохладную подвалную среду, важную для длительного хранения продуктов.",
  "signalslink:usageinfo-signalslink-text": "    <font size=\"25\"><strong>SignalsLink<\\/strong><\\/font>    <br>    Расширяет мод <a href=\"handbook://signals:craftinginfo-signals\">Signals<\\/a> дополнительными компонентами.    <br>    <br>    Для отслеживания какого-либо блока поблизости вы можете использовать <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Датчик блоков<\\/a>.    <br>    Если вам нужно следить за вашим стадом скота, отлично подойдёт <a href=\"handbook://block-signalslink:entitysensor-off-north-down\">Датчик существ<\\/a>.    <br>    Если вы хотите автоматизировать некоторые работы, вам прекрасно послужит <a href=\"handbook://block-signalslink:managedchute-north-down\">Управляемый желоб<\\/a>, который умеет перемещать предметы между блоками подобно желобу, но вы управляете им сигналами и получаете гораздо больший контроль над тем, что перемещается. Его вариант <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">Управляемый желоб, встроенный в стену<\\/a>, затем позволяет перемещать предметы сквозь стены, что может быть очень полезно для скрытых транспортных систем или для перемещения предметов из подвала или в подвал, не нарушая прохладную подвалную среду, важную для длительного хранения продуктов.",
  "signalslink:usageinfo-paperconditions-text": "    Некоторые блоки из мода <a href=\"handbook://signalslink:usageinfo-signalslink\">SignalsLink<\\/a> позволяют использовать <strong>условия на бумаге<\\/strong>:    <br>    • <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Датчик блоков<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedchute-north-down\">Управляемый желоб<\\/a>    <br>    • <a href=\"handbook://block-signalslink:managedwallchute-rock-granite-north-north\">Управляемый желоб, встроенный в стену<\\/a>    <br>    <font size=\"20\" color=\"6082B6\">Условия на бумаге<\\/font>    <strong>условия на бумаге<\\/strong> — это условия, написанные на <a href=\"handbook://item-paper-parchment\">пергаменте<\\/a>. Эти условия могут использоваться для влияния на поведение блока, например для управления выходными сигналами или для фильтрации предметов в желобах.    <br>    Условия записываются в блоки (абзацы). Каждый блок состоит из одной или нескольких строк, при этом в каждой строке указано одно условие. Все условия <strong>в одном блоке<\\/strong> оцениваются так, что между ними применяется логический оператор AND, и результат даёт итоговое значение всего блока.    <br>    Отдельные блоки разделяются пустой строкой. К итоговым значениям отдельных блоков затем применяется логический оператор OR. Оценка отдельных условий в блоке выполняется в порядке сверху вниз, в каком условия указаны на бумаге. Оценка блоков также происходит в том порядке, в котором блоки указаны на бумаге. Это значит, что как только какой-либо блок оценивается как истина (true), этот результат возвращается в вызывающий блок, и к следующему блоку уже не переходят. Это очень важно, и с этим нужно считаться.    <br>    <br>    Различаем несколько типов условий:    <br>    <strong>game:plank-oak<\\/strong> - Оценивается, является ли отслеживаемый предмет в инвентаре или отслеживаемый блок указанного типа, т. е. его код в точности соответствует заданному коду. Если да, условие возвращает true.<br>    <strong>game:plank-*<\\/strong> - Оценивается, является ли отслеживаемый предмет или блок указанного типа в любой его варианте (обозначено звёздочкой). Если да, условие возвращает true.<br>    <strong>@.*-plank-.*<\\/strong> - Код отслеживаемого предмета или блока оценивается этим регулярным выражением. Если есть совпадение, условие возвращает true.<br>    <strong>attribut > 1<\\/strong> - Оценивается значение атрибута предмета в инвентаре или отслеживаемого блока. Здесь можно использовать различные операторы сравнения (больше/меньше/равно). После оценки возвращается результат сравнения (true/false).<br>    <strong>attribut<\\/strong> - если в условии указан только атрибут предмета, оценивается, имеет он значение или нет. Т. е. ноль, NULL, пустая строка или false оцениваются как false. Ненулевое значение, строка или true оцениваются как true.<br>    <br>    Ко всем условиям можно применить оператор отрицания <strong>!<\\/strong>. Например, !game:plank-oak оценивается как true, если отслеживаемый предмет или блок не является именно дубовыми досками.    <br>    В конец каждого блока можно добавить инструкцию для установки выходного сигнала, например <strong>output 1<\\/strong>, которая определяет, что если этот блок оценивается как истина (true), на выход будет отправлен сигнал 1. Это имеет значение только для блока <a href=\"handbook://block-signalslink:blocksensor-off-fwd-north-down\">Датчик блоков<\\/a>, который позволяет настроить, какой сигнал будет отправлен на выход в случае, если какой-либо блок или предмет соответствует условиям, указанным в блоке. У остальных блоков, которые позволяют использовать условия на бумаге, эта инструкция игнорируется.    <font size=\"20\" color=\"6082B6\">Настройка условий<\\/font>    Условия вы пишете на <a href=\"handbook://item-paper-parchment\">пергаменте<\\/a>. Пергамент не подписывайте, чтобы вы могли снова редактировать текст.<br>    Условия переносите в блок, который это поддерживает, так: щёлкните этим пергаментом правой кнопкой мыши по данному блоку. Условия таким образом сохраняются в блоке, и вы увидите их в информационном окне, когда посмотрите на блок. <br>    Для удаления условий из блока возьмите в руку пустой пергамент, присядьте (клавиша Shift) и щёлкните этим пустым пергаментом по данному блоку. Так вы удалите условия из блока.<br>    Если вы хотите скопировать условия из блока на пустой пергамент, щёлкните пустым пергаментом правой кнопкой мыши по данному блоку без приседа.<br>    И напоследок подсказка, как узнать, какой код имеет какой-либо блок или предмет и какие у вас есть доступные атрибуты для использования в условных выражениях:<br>    Возьмите в руку предмет, который вас интересует, удерживайте клавишу Ctrl и щёлкните правой кнопкой мыши этим блоком по блоку, который поддерживает условия на бумаге. Код предмета и его атрибуты, доступные для условий на бумаге, сохранятся в этот блок. Теперь вы можете скопировать их на пустой пергамент, как было описано выше, и там произвольно отредактировать на блоки условий и использовать их для настройки блока.",
  "signalslink:usageinfo-paperconditions-title": "Условия на бумаге"
}
